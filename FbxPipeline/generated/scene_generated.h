// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_SCENE_APEMODEFB_H_
#define FLATBUFFERS_GENERATED_SCENE_APEMODEFB_H_

#include "flatbuffers/flatbuffers.h"

namespace apemodefb {

struct Vec2Fb;

struct Vec3Fb;

struct Vec4Fb;

struct Mat4Fb;

struct StaticVertexFb;

struct PackedVertexFb;

struct StaticSkinnedVertexFb;

struct PackedSkinnedVertexFb;

struct AnimStackFb;

struct AnimLayerFb;

struct AnimCurveKeyFb;

struct AnimCurveFb;

struct TextureFb;

struct SubmeshFb;

struct SubsetFb;

struct NameFb;

struct TransformFb;

struct SkinFb;

struct MeshFb;

struct MaterialPropFb;

struct MaterialFb;

struct CameraFb;

struct LightFb;

struct NodeFb;

struct FileFb;

struct SceneFb;

enum EVersionFb {
  EVersionFb_Value = 5,
  EVersionFb_MIN = EVersionFb_Value,
  EVersionFb_MAX = EVersionFb_Value
};

inline EVersionFb (&EnumValuesEVersionFb())[1] {
  static EVersionFb values[] = {
    EVersionFb_Value
  };
  return values;
}

inline const char **EnumNamesEVersionFb() {
  static const char *names[] = {
    "Value",
    nullptr
  };
  return names;
}

inline const char *EnumNameEVersionFb(EVersionFb e) {
  const size_t index = static_cast<int>(e) - static_cast<int>(EVersionFb_Value);
  return EnumNamesEVersionFb()[index];
}

enum ECullingTypeFb {
  ECullingTypeFb_CullingOff = 0,
  ECullingTypeFb_CullingOnCCW = 1,
  ECullingTypeFb_CullingOnCW = 2,
  ECullingTypeFb_MIN = ECullingTypeFb_CullingOff,
  ECullingTypeFb_MAX = ECullingTypeFb_CullingOnCW
};

inline ECullingTypeFb (&EnumValuesECullingTypeFb())[3] {
  static ECullingTypeFb values[] = {
    ECullingTypeFb_CullingOff,
    ECullingTypeFb_CullingOnCCW,
    ECullingTypeFb_CullingOnCW
  };
  return values;
}

inline const char **EnumNamesECullingTypeFb() {
  static const char *names[] = {
    "CullingOff",
    "CullingOnCCW",
    "CullingOnCW",
    nullptr
  };
  return names;
}

inline const char *EnumNameECullingTypeFb(ECullingTypeFb e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesECullingTypeFb()[index];
}

enum EWrapModeFb {
  EWrapModeFb_Repeat = 0,
  EWrapModeFb_Clamp = 1,
  EWrapModeFb_MIN = EWrapModeFb_Repeat,
  EWrapModeFb_MAX = EWrapModeFb_Clamp
};

inline EWrapModeFb (&EnumValuesEWrapModeFb())[2] {
  static EWrapModeFb values[] = {
    EWrapModeFb_Repeat,
    EWrapModeFb_Clamp
  };
  return values;
}

inline const char **EnumNamesEWrapModeFb() {
  static const char *names[] = {
    "Repeat",
    "Clamp",
    nullptr
  };
  return names;
}

inline const char *EnumNameEWrapModeFb(EWrapModeFb e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEWrapModeFb()[index];
}

enum EBlendModeFb {
  EBlendModeFb_Translucent = 0,
  EBlendModeFb_Additive = 1,
  EBlendModeFb_Modulate = 2,
  EBlendModeFb_Modulate2 = 3,
  EBlendModeFb_Over = 4,
  EBlendModeFb_MIN = EBlendModeFb_Translucent,
  EBlendModeFb_MAX = EBlendModeFb_Over
};

inline EBlendModeFb (&EnumValuesEBlendModeFb())[5] {
  static EBlendModeFb values[] = {
    EBlendModeFb_Translucent,
    EBlendModeFb_Additive,
    EBlendModeFb_Modulate,
    EBlendModeFb_Modulate2,
    EBlendModeFb_Over
  };
  return values;
}

inline const char **EnumNamesEBlendModeFb() {
  static const char *names[] = {
    "Translucent",
    "Additive",
    "Modulate",
    "Modulate2",
    "Over",
    nullptr
  };
  return names;
}

inline const char *EnumNameEBlendModeFb(EBlendModeFb e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEBlendModeFb()[index];
}

enum EAlphaSourceFb {
  EAlphaSourceFb_None = 0,
  EAlphaSourceFb_RGBIntensity = 1,
  EAlphaSourceFb_Black = 2,
  EAlphaSourceFb_MIN = EAlphaSourceFb_None,
  EAlphaSourceFb_MAX = EAlphaSourceFb_Black
};

inline EAlphaSourceFb (&EnumValuesEAlphaSourceFb())[3] {
  static EAlphaSourceFb values[] = {
    EAlphaSourceFb_None,
    EAlphaSourceFb_RGBIntensity,
    EAlphaSourceFb_Black
  };
  return values;
}

inline const char **EnumNamesEAlphaSourceFb() {
  static const char *names[] = {
    "None",
    "RGBIntensity",
    "Black",
    nullptr
  };
  return names;
}

inline const char *EnumNameEAlphaSourceFb(EAlphaSourceFb e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEAlphaSourceFb()[index];
}

enum ETextureUseFb {
  ETextureUseFb_Standard = 0,
  ETextureUseFb_ShadowMap = 1,
  ETextureUseFb_LightMap = 2,
  ETextureUseFb_SphericalReflectionMap = 3,
  ETextureUseFb_SphereReflectionMap = 4,
  ETextureUseFb_BumpNormalMap = 5,
  ETextureUseFb_MIN = ETextureUseFb_Standard,
  ETextureUseFb_MAX = ETextureUseFb_BumpNormalMap
};

inline ETextureUseFb (&EnumValuesETextureUseFb())[6] {
  static ETextureUseFb values[] = {
    ETextureUseFb_Standard,
    ETextureUseFb_ShadowMap,
    ETextureUseFb_LightMap,
    ETextureUseFb_SphericalReflectionMap,
    ETextureUseFb_SphereReflectionMap,
    ETextureUseFb_BumpNormalMap
  };
  return values;
}

inline const char **EnumNamesETextureUseFb() {
  static const char *names[] = {
    "Standard",
    "ShadowMap",
    "LightMap",
    "SphericalReflectionMap",
    "SphereReflectionMap",
    "BumpNormalMap",
    nullptr
  };
  return names;
}

inline const char *EnumNameETextureUseFb(ETextureUseFb e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesETextureUseFb()[index];
}

enum EMappingTypeFb {
  EMappingTypeFb_Null = 0,
  EMappingTypeFb_Planar = 1,
  EMappingTypeFb_Spherical = 2,
  EMappingTypeFb_Cylindrical = 3,
  EMappingTypeFb_Box = 4,
  EMappingTypeFb_Face = 5,
  EMappingTypeFb_UV = 6,
  EMappingTypeFb_Environment = 7,
  EMappingTypeFb_MIN = EMappingTypeFb_Null,
  EMappingTypeFb_MAX = EMappingTypeFb_Environment
};

inline EMappingTypeFb (&EnumValuesEMappingTypeFb())[8] {
  static EMappingTypeFb values[] = {
    EMappingTypeFb_Null,
    EMappingTypeFb_Planar,
    EMappingTypeFb_Spherical,
    EMappingTypeFb_Cylindrical,
    EMappingTypeFb_Box,
    EMappingTypeFb_Face,
    EMappingTypeFb_UV,
    EMappingTypeFb_Environment
  };
  return values;
}

inline const char **EnumNamesEMappingTypeFb() {
  static const char *names[] = {
    "Null",
    "Planar",
    "Spherical",
    "Cylindrical",
    "Box",
    "Face",
    "UV",
    "Environment",
    nullptr
  };
  return names;
}

inline const char *EnumNameEMappingTypeFb(EMappingTypeFb e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEMappingTypeFb()[index];
}

enum EPlanarMappingNormalFb {
  EPlanarMappingNormalFb_PlanarNormalX = 0,
  EPlanarMappingNormalFb_PlanarNormalY = 1,
  EPlanarMappingNormalFb_PlanarNormalZ = 2,
  EPlanarMappingNormalFb_MIN = EPlanarMappingNormalFb_PlanarNormalX,
  EPlanarMappingNormalFb_MAX = EPlanarMappingNormalFb_PlanarNormalZ
};

inline EPlanarMappingNormalFb (&EnumValuesEPlanarMappingNormalFb())[3] {
  static EPlanarMappingNormalFb values[] = {
    EPlanarMappingNormalFb_PlanarNormalX,
    EPlanarMappingNormalFb_PlanarNormalY,
    EPlanarMappingNormalFb_PlanarNormalZ
  };
  return values;
}

inline const char **EnumNamesEPlanarMappingNormalFb() {
  static const char *names[] = {
    "PlanarNormalX",
    "PlanarNormalY",
    "PlanarNormalZ",
    nullptr
  };
  return names;
}

inline const char *EnumNameEPlanarMappingNormalFb(EPlanarMappingNormalFb e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEPlanarMappingNormalFb()[index];
}

enum EVertexFormatFb {
  EVertexFormatFb_Static = 0,
  EVertexFormatFb_StaticSkinned = 1,
  EVertexFormatFb_Packed = 2,
  EVertexFormatFb_PackedSkinned = 3,
  EVertexFormatFb_MIN = EVertexFormatFb_Static,
  EVertexFormatFb_MAX = EVertexFormatFb_PackedSkinned
};

inline EVertexFormatFb (&EnumValuesEVertexFormatFb())[4] {
  static EVertexFormatFb values[] = {
    EVertexFormatFb_Static,
    EVertexFormatFb_StaticSkinned,
    EVertexFormatFb_Packed,
    EVertexFormatFb_PackedSkinned
  };
  return values;
}

inline const char **EnumNamesEVertexFormatFb() {
  static const char *names[] = {
    "Static",
    "StaticSkinned",
    "Packed",
    "PackedSkinned",
    nullptr
  };
  return names;
}

inline const char *EnumNameEVertexFormatFb(EVertexFormatFb e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEVertexFormatFb()[index];
}

enum EIndexTypeFb {
  EIndexTypeFb_UInt16 = 0,
  EIndexTypeFb_UInt16Compressed = 1,
  EIndexTypeFb_UInt32 = 2,
  EIndexTypeFb_UInt32Compressed = 3,
  EIndexTypeFb_Count = 4,
  EIndexTypeFb_MIN = EIndexTypeFb_UInt16,
  EIndexTypeFb_MAX = EIndexTypeFb_Count
};

inline EIndexTypeFb (&EnumValuesEIndexTypeFb())[5] {
  static EIndexTypeFb values[] = {
    EIndexTypeFb_UInt16,
    EIndexTypeFb_UInt16Compressed,
    EIndexTypeFb_UInt32,
    EIndexTypeFb_UInt32Compressed,
    EIndexTypeFb_Count
  };
  return values;
}

inline const char **EnumNamesEIndexTypeFb() {
  static const char *names[] = {
    "UInt16",
    "UInt16Compressed",
    "UInt32",
    "UInt32Compressed",
    "Count",
    nullptr
  };
  return names;
}

inline const char *EnumNameEIndexTypeFb(EIndexTypeFb e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEIndexTypeFb()[index];
}

enum EMaterialPropTypeFb {
  EMaterialPropTypeFb_Bool = 0,
  EMaterialPropTypeFb_Float = 1,
  EMaterialPropTypeFb_Float2 = 2,
  EMaterialPropTypeFb_Float3 = 3,
  EMaterialPropTypeFb_Texture = 4,
  EMaterialPropTypeFb_MIN = EMaterialPropTypeFb_Bool,
  EMaterialPropTypeFb_MAX = EMaterialPropTypeFb_Texture
};

inline EMaterialPropTypeFb (&EnumValuesEMaterialPropTypeFb())[5] {
  static EMaterialPropTypeFb values[] = {
    EMaterialPropTypeFb_Bool,
    EMaterialPropTypeFb_Float,
    EMaterialPropTypeFb_Float2,
    EMaterialPropTypeFb_Float3,
    EMaterialPropTypeFb_Texture
  };
  return values;
}

inline const char **EnumNamesEMaterialPropTypeFb() {
  static const char *names[] = {
    "Bool",
    "Float",
    "Float2",
    "Float3",
    "Texture",
    nullptr
  };
  return names;
}

inline const char *EnumNameEMaterialPropTypeFb(EMaterialPropTypeFb e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEMaterialPropTypeFb()[index];
}

enum EAnimCurvePropertyFb {
  EAnimCurvePropertyFb_LclTranslation = 0,
  EAnimCurvePropertyFb_RotationOffset = 1,
  EAnimCurvePropertyFb_RotationPivot = 2,
  EAnimCurvePropertyFb_PreRotation = 3,
  EAnimCurvePropertyFb_PostRotation = 4,
  EAnimCurvePropertyFb_LclRotation = 5,
  EAnimCurvePropertyFb_ScalingOffset = 6,
  EAnimCurvePropertyFb_ScalingPivot = 7,
  EAnimCurvePropertyFb_LclScaling = 8,
  EAnimCurvePropertyFb_GeometricTranslation = 9,
  EAnimCurvePropertyFb_GeometricRotation = 10,
  EAnimCurvePropertyFb_GeometricScaling = 11,
  EAnimCurvePropertyFb_MIN = EAnimCurvePropertyFb_LclTranslation,
  EAnimCurvePropertyFb_MAX = EAnimCurvePropertyFb_GeometricScaling
};

inline EAnimCurvePropertyFb (&EnumValuesEAnimCurvePropertyFb())[12] {
  static EAnimCurvePropertyFb values[] = {
    EAnimCurvePropertyFb_LclTranslation,
    EAnimCurvePropertyFb_RotationOffset,
    EAnimCurvePropertyFb_RotationPivot,
    EAnimCurvePropertyFb_PreRotation,
    EAnimCurvePropertyFb_PostRotation,
    EAnimCurvePropertyFb_LclRotation,
    EAnimCurvePropertyFb_ScalingOffset,
    EAnimCurvePropertyFb_ScalingPivot,
    EAnimCurvePropertyFb_LclScaling,
    EAnimCurvePropertyFb_GeometricTranslation,
    EAnimCurvePropertyFb_GeometricRotation,
    EAnimCurvePropertyFb_GeometricScaling
  };
  return values;
}

inline const char **EnumNamesEAnimCurvePropertyFb() {
  static const char *names[] = {
    "LclTranslation",
    "RotationOffset",
    "RotationPivot",
    "PreRotation",
    "PostRotation",
    "LclRotation",
    "ScalingOffset",
    "ScalingPivot",
    "LclScaling",
    "GeometricTranslation",
    "GeometricRotation",
    "GeometricScaling",
    nullptr
  };
  return names;
}

inline const char *EnumNameEAnimCurvePropertyFb(EAnimCurvePropertyFb e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEAnimCurvePropertyFb()[index];
}

enum EAnimCurveChannelFb {
  EAnimCurveChannelFb_X = 0,
  EAnimCurveChannelFb_Y = 1,
  EAnimCurveChannelFb_Z = 2,
  EAnimCurveChannelFb_MIN = EAnimCurveChannelFb_X,
  EAnimCurveChannelFb_MAX = EAnimCurveChannelFb_Z
};

inline EAnimCurveChannelFb (&EnumValuesEAnimCurveChannelFb())[3] {
  static EAnimCurveChannelFb values[] = {
    EAnimCurveChannelFb_X,
    EAnimCurveChannelFb_Y,
    EAnimCurveChannelFb_Z
  };
  return values;
}

inline const char **EnumNamesEAnimCurveChannelFb() {
  static const char *names[] = {
    "X",
    "Y",
    "Z",
    nullptr
  };
  return names;
}

inline const char *EnumNameEAnimCurveChannelFb(EAnimCurveChannelFb e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEAnimCurveChannelFb()[index];
}

enum EInterpolationModeFb {
  EInterpolationModeFb_Const = 0,
  EInterpolationModeFb_Linear = 1,
  EInterpolationModeFb_Cubic = 2,
  EInterpolationModeFb_MIN = EInterpolationModeFb_Const,
  EInterpolationModeFb_MAX = EInterpolationModeFb_Cubic
};

inline EInterpolationModeFb (&EnumValuesEInterpolationModeFb())[3] {
  static EInterpolationModeFb values[] = {
    EInterpolationModeFb_Const,
    EInterpolationModeFb_Linear,
    EInterpolationModeFb_Cubic
  };
  return values;
}

inline const char **EnumNamesEInterpolationModeFb() {
  static const char *names[] = {
    "Const",
    "Linear",
    "Cubic",
    nullptr
  };
  return names;
}

inline const char *EnumNameEInterpolationModeFb(EInterpolationModeFb e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEInterpolationModeFb()[index];
}

enum ELightTypeFb {
  ELightTypeFb_Point = 0,
  ELightTypeFb_Directional = 1,
  ELightTypeFb_Spot = 2,
  ELightTypeFb_Area = 3,
  ELightTypeFb_MIN = ELightTypeFb_Point,
  ELightTypeFb_MAX = ELightTypeFb_Area
};

inline ELightTypeFb (&EnumValuesELightTypeFb())[4] {
  static ELightTypeFb values[] = {
    ELightTypeFb_Point,
    ELightTypeFb_Directional,
    ELightTypeFb_Spot,
    ELightTypeFb_Area
  };
  return values;
}

inline const char **EnumNamesELightTypeFb() {
  static const char *names[] = {
    "Point",
    "Directional",
    "Spot",
    "Area",
    nullptr
  };
  return names;
}

inline const char *EnumNameELightTypeFb(ELightTypeFb e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesELightTypeFb()[index];
}

enum EAreaLightTypeFb {
  EAreaLightTypeFb_Rect = 0,
  EAreaLightTypeFb_Sphere = 1,
  EAreaLightTypeFb_MIN = EAreaLightTypeFb_Rect,
  EAreaLightTypeFb_MAX = EAreaLightTypeFb_Sphere
};

inline EAreaLightTypeFb (&EnumValuesEAreaLightTypeFb())[2] {
  static EAreaLightTypeFb values[] = {
    EAreaLightTypeFb_Rect,
    EAreaLightTypeFb_Sphere
  };
  return values;
}

inline const char **EnumNamesEAreaLightTypeFb() {
  static const char *names[] = {
    "Rect",
    "Sphere",
    nullptr
  };
  return names;
}

inline const char *EnumNameEAreaLightTypeFb(EAreaLightTypeFb e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEAreaLightTypeFb()[index];
}

enum EValueTypeFb {
  EValueTypeFb_Bool = 0,
  EValueTypeFb_Int = 1,
  EValueTypeFb_Float = 2,
  EValueTypeFb_Float2 = 3,
  EValueTypeFb_Float3 = 4,
  EValueTypeFb_Float4 = 5,
  EValueTypeFb_String = 6,
  EValueTypeFb_MIN = EValueTypeFb_Bool,
  EValueTypeFb_MAX = EValueTypeFb_String
};

inline EValueTypeFb (&EnumValuesEValueTypeFb())[7] {
  static EValueTypeFb values[] = {
    EValueTypeFb_Bool,
    EValueTypeFb_Int,
    EValueTypeFb_Float,
    EValueTypeFb_Float2,
    EValueTypeFb_Float3,
    EValueTypeFb_Float4,
    EValueTypeFb_String
  };
  return values;
}

inline const char **EnumNamesEValueTypeFb() {
  static const char *names[] = {
    "Bool",
    "Int",
    "Float",
    "Float2",
    "Float3",
    "Float4",
    "String",
    nullptr
  };
  return names;
}

inline const char *EnumNameEValueTypeFb(EValueTypeFb e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesEValueTypeFb()[index];
}

MANUALLY_ALIGNED_STRUCT(4) Vec2Fb FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2Fb() {
    memset(this, 0, sizeof(Vec2Fb));
  }
  Vec2Fb(float _x, float _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
};
STRUCT_END(Vec2Fb, 8);

MANUALLY_ALIGNED_STRUCT(4) Vec3Fb FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3Fb() {
    memset(this, 0, sizeof(Vec3Fb));
  }
  Vec3Fb(float _x, float _y, float _z)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  void mutate_z(float _z) {
    flatbuffers::WriteScalar(&z_, _z);
  }
};
STRUCT_END(Vec3Fb, 12);

MANUALLY_ALIGNED_STRUCT(4) Vec4Fb FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;
  float w_;

 public:
  Vec4Fb() {
    memset(this, 0, sizeof(Vec4Fb));
  }
  Vec4Fb(float _x, float _y, float _z, float _w)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)),
        z_(flatbuffers::EndianScalar(_z)),
        w_(flatbuffers::EndianScalar(_w)) {
  }
  float x() const {
    return flatbuffers::EndianScalar(x_);
  }
  void mutate_x(float _x) {
    flatbuffers::WriteScalar(&x_, _x);
  }
  float y() const {
    return flatbuffers::EndianScalar(y_);
  }
  void mutate_y(float _y) {
    flatbuffers::WriteScalar(&y_, _y);
  }
  float z() const {
    return flatbuffers::EndianScalar(z_);
  }
  void mutate_z(float _z) {
    flatbuffers::WriteScalar(&z_, _z);
  }
  float w() const {
    return flatbuffers::EndianScalar(w_);
  }
  void mutate_w(float _w) {
    flatbuffers::WriteScalar(&w_, _w);
  }
};
STRUCT_END(Vec4Fb, 16);

MANUALLY_ALIGNED_STRUCT(4) Mat4Fb FLATBUFFERS_FINAL_CLASS {
 private:
  Vec4Fb x_;
  Vec4Fb y_;
  Vec4Fb z_;
  Vec4Fb w_;

 public:
  Mat4Fb() {
    memset(this, 0, sizeof(Mat4Fb));
  }
  Mat4Fb(const Vec4Fb &_x, const Vec4Fb &_y, const Vec4Fb &_z, const Vec4Fb &_w)
      : x_(_x),
        y_(_y),
        z_(_z),
        w_(_w) {
  }
  const Vec4Fb &x() const {
    return x_;
  }
  Vec4Fb &mutable_x() {
    return x_;
  }
  const Vec4Fb &y() const {
    return y_;
  }
  Vec4Fb &mutable_y() {
    return y_;
  }
  const Vec4Fb &z() const {
    return z_;
  }
  Vec4Fb &mutable_z() {
    return z_;
  }
  const Vec4Fb &w() const {
    return w_;
  }
  Vec4Fb &mutable_w() {
    return w_;
  }
};
STRUCT_END(Mat4Fb, 64);

MANUALLY_ALIGNED_STRUCT(4) StaticVertexFb FLATBUFFERS_FINAL_CLASS {
 private:
  Vec3Fb position_;
  Vec3Fb normal_;
  Vec4Fb tangent_;
  Vec2Fb uv_;

 public:
  StaticVertexFb() {
    memset(this, 0, sizeof(StaticVertexFb));
  }
  StaticVertexFb(const Vec3Fb &_position, const Vec3Fb &_normal, const Vec4Fb &_tangent, const Vec2Fb &_uv)
      : position_(_position),
        normal_(_normal),
        tangent_(_tangent),
        uv_(_uv) {
  }
  const Vec3Fb &position() const {
    return position_;
  }
  Vec3Fb &mutable_position() {
    return position_;
  }
  const Vec3Fb &normal() const {
    return normal_;
  }
  Vec3Fb &mutable_normal() {
    return normal_;
  }
  const Vec4Fb &tangent() const {
    return tangent_;
  }
  Vec4Fb &mutable_tangent() {
    return tangent_;
  }
  const Vec2Fb &uv() const {
    return uv_;
  }
  Vec2Fb &mutable_uv() {
    return uv_;
  }
};
STRUCT_END(StaticVertexFb, 48);

MANUALLY_ALIGNED_STRUCT(4) PackedVertexFb FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t position_;
  uint32_t normal_;
  uint32_t tangent_;
  uint32_t uv_;

 public:
  PackedVertexFb() {
    memset(this, 0, sizeof(PackedVertexFb));
  }
  PackedVertexFb(uint32_t _position, uint32_t _normal, uint32_t _tangent, uint32_t _uv)
      : position_(flatbuffers::EndianScalar(_position)),
        normal_(flatbuffers::EndianScalar(_normal)),
        tangent_(flatbuffers::EndianScalar(_tangent)),
        uv_(flatbuffers::EndianScalar(_uv)) {
  }
  uint32_t position() const {
    return flatbuffers::EndianScalar(position_);
  }
  void mutate_position(uint32_t _position) {
    flatbuffers::WriteScalar(&position_, _position);
  }
  uint32_t normal() const {
    return flatbuffers::EndianScalar(normal_);
  }
  void mutate_normal(uint32_t _normal) {
    flatbuffers::WriteScalar(&normal_, _normal);
  }
  uint32_t tangent() const {
    return flatbuffers::EndianScalar(tangent_);
  }
  void mutate_tangent(uint32_t _tangent) {
    flatbuffers::WriteScalar(&tangent_, _tangent);
  }
  uint32_t uv() const {
    return flatbuffers::EndianScalar(uv_);
  }
  void mutate_uv(uint32_t _uv) {
    flatbuffers::WriteScalar(&uv_, _uv);
  }
};
STRUCT_END(PackedVertexFb, 16);

MANUALLY_ALIGNED_STRUCT(4) StaticSkinnedVertexFb FLATBUFFERS_FINAL_CLASS {
 private:
  Vec3Fb position_;
  Vec3Fb normal_;
  Vec4Fb tangent_;
  Vec2Fb uv_;
  Vec4Fb weights_;
  Vec4Fb indices_;

 public:
  StaticSkinnedVertexFb() {
    memset(this, 0, sizeof(StaticSkinnedVertexFb));
  }
  StaticSkinnedVertexFb(const Vec3Fb &_position, const Vec3Fb &_normal, const Vec4Fb &_tangent, const Vec2Fb &_uv, const Vec4Fb &_weights, const Vec4Fb &_indices)
      : position_(_position),
        normal_(_normal),
        tangent_(_tangent),
        uv_(_uv),
        weights_(_weights),
        indices_(_indices) {
  }
  const Vec3Fb &position() const {
    return position_;
  }
  Vec3Fb &mutable_position() {
    return position_;
  }
  const Vec3Fb &normal() const {
    return normal_;
  }
  Vec3Fb &mutable_normal() {
    return normal_;
  }
  const Vec4Fb &tangent() const {
    return tangent_;
  }
  Vec4Fb &mutable_tangent() {
    return tangent_;
  }
  const Vec2Fb &uv() const {
    return uv_;
  }
  Vec2Fb &mutable_uv() {
    return uv_;
  }
  const Vec4Fb &weights() const {
    return weights_;
  }
  Vec4Fb &mutable_weights() {
    return weights_;
  }
  const Vec4Fb &indices() const {
    return indices_;
  }
  Vec4Fb &mutable_indices() {
    return indices_;
  }
};
STRUCT_END(StaticSkinnedVertexFb, 80);

MANUALLY_ALIGNED_STRUCT(4) PackedSkinnedVertexFb FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t position_;
  uint32_t normal_;
  uint32_t tangent_;
  uint32_t uv_;
  uint32_t weights_;
  uint32_t indices_;

 public:
  PackedSkinnedVertexFb() {
    memset(this, 0, sizeof(PackedSkinnedVertexFb));
  }
  PackedSkinnedVertexFb(uint32_t _position, uint32_t _normal, uint32_t _tangent, uint32_t _uv, uint32_t _weights, uint32_t _indices)
      : position_(flatbuffers::EndianScalar(_position)),
        normal_(flatbuffers::EndianScalar(_normal)),
        tangent_(flatbuffers::EndianScalar(_tangent)),
        uv_(flatbuffers::EndianScalar(_uv)),
        weights_(flatbuffers::EndianScalar(_weights)),
        indices_(flatbuffers::EndianScalar(_indices)) {
  }
  uint32_t position() const {
    return flatbuffers::EndianScalar(position_);
  }
  void mutate_position(uint32_t _position) {
    flatbuffers::WriteScalar(&position_, _position);
  }
  uint32_t normal() const {
    return flatbuffers::EndianScalar(normal_);
  }
  void mutate_normal(uint32_t _normal) {
    flatbuffers::WriteScalar(&normal_, _normal);
  }
  uint32_t tangent() const {
    return flatbuffers::EndianScalar(tangent_);
  }
  void mutate_tangent(uint32_t _tangent) {
    flatbuffers::WriteScalar(&tangent_, _tangent);
  }
  uint32_t uv() const {
    return flatbuffers::EndianScalar(uv_);
  }
  void mutate_uv(uint32_t _uv) {
    flatbuffers::WriteScalar(&uv_, _uv);
  }
  uint32_t weights() const {
    return flatbuffers::EndianScalar(weights_);
  }
  void mutate_weights(uint32_t _weights) {
    flatbuffers::WriteScalar(&weights_, _weights);
  }
  uint32_t indices() const {
    return flatbuffers::EndianScalar(indices_);
  }
  void mutate_indices(uint32_t _indices) {
    flatbuffers::WriteScalar(&indices_, _indices);
  }
};
STRUCT_END(PackedSkinnedVertexFb, 24);

MANUALLY_ALIGNED_STRUCT(4) AnimStackFb FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t id_;
  uint32_t name_id_;

 public:
  AnimStackFb() {
    memset(this, 0, sizeof(AnimStackFb));
  }
  AnimStackFb(uint32_t _id, uint32_t _name_id)
      : id_(flatbuffers::EndianScalar(_id)),
        name_id_(flatbuffers::EndianScalar(_name_id)) {
  }
  uint32_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
  void mutate_id(uint32_t _id) {
    flatbuffers::WriteScalar(&id_, _id);
  }
  uint32_t name_id() const {
    return flatbuffers::EndianScalar(name_id_);
  }
  void mutate_name_id(uint32_t _name_id) {
    flatbuffers::WriteScalar(&name_id_, _name_id);
  }
  bool KeyCompareLessThan(const AnimStackFb *o) const {
    return name_id() < o->name_id();
  }
  int KeyCompareWithValue(uint32_t val) const {
    const auto key = name_id();
    return static_cast<int>(key > val) - static_cast<int>(key < val);
  }
};
STRUCT_END(AnimStackFb, 8);

MANUALLY_ALIGNED_STRUCT(4) AnimLayerFb FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t id_;
  uint32_t anim_stack_id_;
  uint32_t name_id_;

 public:
  AnimLayerFb() {
    memset(this, 0, sizeof(AnimLayerFb));
  }
  AnimLayerFb(uint32_t _id, uint32_t _anim_stack_id, uint32_t _name_id)
      : id_(flatbuffers::EndianScalar(_id)),
        anim_stack_id_(flatbuffers::EndianScalar(_anim_stack_id)),
        name_id_(flatbuffers::EndianScalar(_name_id)) {
  }
  uint32_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
  void mutate_id(uint32_t _id) {
    flatbuffers::WriteScalar(&id_, _id);
  }
  uint32_t anim_stack_id() const {
    return flatbuffers::EndianScalar(anim_stack_id_);
  }
  void mutate_anim_stack_id(uint32_t _anim_stack_id) {
    flatbuffers::WriteScalar(&anim_stack_id_, _anim_stack_id);
  }
  uint32_t name_id() const {
    return flatbuffers::EndianScalar(name_id_);
  }
  void mutate_name_id(uint32_t _name_id) {
    flatbuffers::WriteScalar(&name_id_, _name_id);
  }
  bool KeyCompareLessThan(const AnimLayerFb *o) const {
    return name_id() < o->name_id();
  }
  int KeyCompareWithValue(uint32_t val) const {
    const auto key = name_id();
    return static_cast<int>(key > val) - static_cast<int>(key < val);
  }
};
STRUCT_END(AnimLayerFb, 12);

MANUALLY_ALIGNED_STRUCT(4) AnimCurveKeyFb FLATBUFFERS_FINAL_CLASS {
 private:
  float time_;
  float value_;

 public:
  AnimCurveKeyFb() {
    memset(this, 0, sizeof(AnimCurveKeyFb));
  }
  AnimCurveKeyFb(float _time, float _value)
      : time_(flatbuffers::EndianScalar(_time)),
        value_(flatbuffers::EndianScalar(_value)) {
  }
  float time() const {
    return flatbuffers::EndianScalar(time_);
  }
  void mutate_time(float _time) {
    flatbuffers::WriteScalar(&time_, _time);
  }
  float value() const {
    return flatbuffers::EndianScalar(value_);
  }
  void mutate_value(float _value) {
    flatbuffers::WriteScalar(&value_, _value);
  }
};
STRUCT_END(AnimCurveKeyFb, 8);

MANUALLY_ALIGNED_STRUCT(4) TextureFb FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t id_;
  uint32_t name_id_;
  uint32_t file_id_;
  uint32_t texture_type_id_;
  uint8_t blend_mode_;
  uint8_t wrap_mode_u_;
  uint8_t wrap_mode_v_;
  int8_t padding0__;
  float offset_u_;
  float offset_v_;
  float scale_u_;
  float scale_v_;
  int32_t cropping_bottom_;
  int32_t cropping_left_;
  int32_t cropping_right_;
  int32_t cropping_top_;
  float rotation_u_;
  float rotation_v_;
  float rotation_w_;
  uint8_t swap_uv_;
  uint8_t wipe_mode_;
  uint8_t premultiplied_alpha_;
  uint8_t alpha_source_;
  uint8_t texture_use_;
  uint8_t mapping_type_;
  uint8_t planar_mapping_normal_;
  int8_t padding1__;

 public:
  TextureFb() {
    memset(this, 0, sizeof(TextureFb));
  }
  TextureFb(uint32_t _id, uint32_t _name_id, uint32_t _file_id, uint32_t _texture_type_id, EBlendModeFb _blend_mode, EWrapModeFb _wrap_mode_u, EWrapModeFb _wrap_mode_v, float _offset_u, float _offset_v, float _scale_u, float _scale_v, int32_t _cropping_bottom, int32_t _cropping_left, int32_t _cropping_right, int32_t _cropping_top, float _rotation_u, float _rotation_v, float _rotation_w, bool _swap_uv, bool _wipe_mode, bool _premultiplied_alpha, EAlphaSourceFb _alpha_source, ETextureUseFb _texture_use, EMappingTypeFb _mapping_type, EPlanarMappingNormalFb _planar_mapping_normal)
      : id_(flatbuffers::EndianScalar(_id)),
        name_id_(flatbuffers::EndianScalar(_name_id)),
        file_id_(flatbuffers::EndianScalar(_file_id)),
        texture_type_id_(flatbuffers::EndianScalar(_texture_type_id)),
        blend_mode_(flatbuffers::EndianScalar(static_cast<uint8_t>(_blend_mode))),
        wrap_mode_u_(flatbuffers::EndianScalar(static_cast<uint8_t>(_wrap_mode_u))),
        wrap_mode_v_(flatbuffers::EndianScalar(static_cast<uint8_t>(_wrap_mode_v))),
        padding0__(0),
        offset_u_(flatbuffers::EndianScalar(_offset_u)),
        offset_v_(flatbuffers::EndianScalar(_offset_v)),
        scale_u_(flatbuffers::EndianScalar(_scale_u)),
        scale_v_(flatbuffers::EndianScalar(_scale_v)),
        cropping_bottom_(flatbuffers::EndianScalar(_cropping_bottom)),
        cropping_left_(flatbuffers::EndianScalar(_cropping_left)),
        cropping_right_(flatbuffers::EndianScalar(_cropping_right)),
        cropping_top_(flatbuffers::EndianScalar(_cropping_top)),
        rotation_u_(flatbuffers::EndianScalar(_rotation_u)),
        rotation_v_(flatbuffers::EndianScalar(_rotation_v)),
        rotation_w_(flatbuffers::EndianScalar(_rotation_w)),
        swap_uv_(flatbuffers::EndianScalar(static_cast<uint8_t>(_swap_uv))),
        wipe_mode_(flatbuffers::EndianScalar(static_cast<uint8_t>(_wipe_mode))),
        premultiplied_alpha_(flatbuffers::EndianScalar(static_cast<uint8_t>(_premultiplied_alpha))),
        alpha_source_(flatbuffers::EndianScalar(static_cast<uint8_t>(_alpha_source))),
        texture_use_(flatbuffers::EndianScalar(static_cast<uint8_t>(_texture_use))),
        mapping_type_(flatbuffers::EndianScalar(static_cast<uint8_t>(_mapping_type))),
        planar_mapping_normal_(flatbuffers::EndianScalar(static_cast<uint8_t>(_planar_mapping_normal))),
        padding1__(0) {
    (void)padding0__;
    (void)padding1__;
  }
  uint32_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
  void mutate_id(uint32_t _id) {
    flatbuffers::WriteScalar(&id_, _id);
  }
  uint32_t name_id() const {
    return flatbuffers::EndianScalar(name_id_);
  }
  void mutate_name_id(uint32_t _name_id) {
    flatbuffers::WriteScalar(&name_id_, _name_id);
  }
  bool KeyCompareLessThan(const TextureFb *o) const {
    return name_id() < o->name_id();
  }
  int KeyCompareWithValue(uint32_t val) const {
    const auto key = name_id();
    return static_cast<int>(key > val) - static_cast<int>(key < val);
  }
  uint32_t file_id() const {
    return flatbuffers::EndianScalar(file_id_);
  }
  void mutate_file_id(uint32_t _file_id) {
    flatbuffers::WriteScalar(&file_id_, _file_id);
  }
  uint32_t texture_type_id() const {
    return flatbuffers::EndianScalar(texture_type_id_);
  }
  void mutate_texture_type_id(uint32_t _texture_type_id) {
    flatbuffers::WriteScalar(&texture_type_id_, _texture_type_id);
  }
  EBlendModeFb blend_mode() const {
    return static_cast<EBlendModeFb>(flatbuffers::EndianScalar(blend_mode_));
  }
  void mutate_blend_mode(EBlendModeFb _blend_mode) {
    flatbuffers::WriteScalar(&blend_mode_, static_cast<uint8_t>(_blend_mode));
  }
  EWrapModeFb wrap_mode_u() const {
    return static_cast<EWrapModeFb>(flatbuffers::EndianScalar(wrap_mode_u_));
  }
  void mutate_wrap_mode_u(EWrapModeFb _wrap_mode_u) {
    flatbuffers::WriteScalar(&wrap_mode_u_, static_cast<uint8_t>(_wrap_mode_u));
  }
  EWrapModeFb wrap_mode_v() const {
    return static_cast<EWrapModeFb>(flatbuffers::EndianScalar(wrap_mode_v_));
  }
  void mutate_wrap_mode_v(EWrapModeFb _wrap_mode_v) {
    flatbuffers::WriteScalar(&wrap_mode_v_, static_cast<uint8_t>(_wrap_mode_v));
  }
  float offset_u() const {
    return flatbuffers::EndianScalar(offset_u_);
  }
  void mutate_offset_u(float _offset_u) {
    flatbuffers::WriteScalar(&offset_u_, _offset_u);
  }
  float offset_v() const {
    return flatbuffers::EndianScalar(offset_v_);
  }
  void mutate_offset_v(float _offset_v) {
    flatbuffers::WriteScalar(&offset_v_, _offset_v);
  }
  float scale_u() const {
    return flatbuffers::EndianScalar(scale_u_);
  }
  void mutate_scale_u(float _scale_u) {
    flatbuffers::WriteScalar(&scale_u_, _scale_u);
  }
  float scale_v() const {
    return flatbuffers::EndianScalar(scale_v_);
  }
  void mutate_scale_v(float _scale_v) {
    flatbuffers::WriteScalar(&scale_v_, _scale_v);
  }
  int32_t cropping_bottom() const {
    return flatbuffers::EndianScalar(cropping_bottom_);
  }
  void mutate_cropping_bottom(int32_t _cropping_bottom) {
    flatbuffers::WriteScalar(&cropping_bottom_, _cropping_bottom);
  }
  int32_t cropping_left() const {
    return flatbuffers::EndianScalar(cropping_left_);
  }
  void mutate_cropping_left(int32_t _cropping_left) {
    flatbuffers::WriteScalar(&cropping_left_, _cropping_left);
  }
  int32_t cropping_right() const {
    return flatbuffers::EndianScalar(cropping_right_);
  }
  void mutate_cropping_right(int32_t _cropping_right) {
    flatbuffers::WriteScalar(&cropping_right_, _cropping_right);
  }
  int32_t cropping_top() const {
    return flatbuffers::EndianScalar(cropping_top_);
  }
  void mutate_cropping_top(int32_t _cropping_top) {
    flatbuffers::WriteScalar(&cropping_top_, _cropping_top);
  }
  float rotation_u() const {
    return flatbuffers::EndianScalar(rotation_u_);
  }
  void mutate_rotation_u(float _rotation_u) {
    flatbuffers::WriteScalar(&rotation_u_, _rotation_u);
  }
  float rotation_v() const {
    return flatbuffers::EndianScalar(rotation_v_);
  }
  void mutate_rotation_v(float _rotation_v) {
    flatbuffers::WriteScalar(&rotation_v_, _rotation_v);
  }
  float rotation_w() const {
    return flatbuffers::EndianScalar(rotation_w_);
  }
  void mutate_rotation_w(float _rotation_w) {
    flatbuffers::WriteScalar(&rotation_w_, _rotation_w);
  }
  bool swap_uv() const {
    return flatbuffers::EndianScalar(swap_uv_) != 0;
  }
  void mutate_swap_uv(bool _swap_uv) {
    flatbuffers::WriteScalar(&swap_uv_, static_cast<uint8_t>(_swap_uv));
  }
  bool wipe_mode() const {
    return flatbuffers::EndianScalar(wipe_mode_) != 0;
  }
  void mutate_wipe_mode(bool _wipe_mode) {
    flatbuffers::WriteScalar(&wipe_mode_, static_cast<uint8_t>(_wipe_mode));
  }
  bool premultiplied_alpha() const {
    return flatbuffers::EndianScalar(premultiplied_alpha_) != 0;
  }
  void mutate_premultiplied_alpha(bool _premultiplied_alpha) {
    flatbuffers::WriteScalar(&premultiplied_alpha_, static_cast<uint8_t>(_premultiplied_alpha));
  }
  EAlphaSourceFb alpha_source() const {
    return static_cast<EAlphaSourceFb>(flatbuffers::EndianScalar(alpha_source_));
  }
  void mutate_alpha_source(EAlphaSourceFb _alpha_source) {
    flatbuffers::WriteScalar(&alpha_source_, static_cast<uint8_t>(_alpha_source));
  }
  ETextureUseFb texture_use() const {
    return static_cast<ETextureUseFb>(flatbuffers::EndianScalar(texture_use_));
  }
  void mutate_texture_use(ETextureUseFb _texture_use) {
    flatbuffers::WriteScalar(&texture_use_, static_cast<uint8_t>(_texture_use));
  }
  EMappingTypeFb mapping_type() const {
    return static_cast<EMappingTypeFb>(flatbuffers::EndianScalar(mapping_type_));
  }
  void mutate_mapping_type(EMappingTypeFb _mapping_type) {
    flatbuffers::WriteScalar(&mapping_type_, static_cast<uint8_t>(_mapping_type));
  }
  EPlanarMappingNormalFb planar_mapping_normal() const {
    return static_cast<EPlanarMappingNormalFb>(flatbuffers::EndianScalar(planar_mapping_normal_));
  }
  void mutate_planar_mapping_normal(EPlanarMappingNormalFb _planar_mapping_normal) {
    flatbuffers::WriteScalar(&planar_mapping_normal_, static_cast<uint8_t>(_planar_mapping_normal));
  }
};
STRUCT_END(TextureFb, 72);

MANUALLY_ALIGNED_STRUCT(4) SubmeshFb FLATBUFFERS_FINAL_CLASS {
 private:
  Vec3Fb bbox_min_;
  Vec3Fb bbox_max_;
  Vec3Fb position_offset_;
  Vec3Fb position_scale_;
  Vec2Fb uv_offset_;
  Vec2Fb uv_scale_;
  uint32_t base_vertex_;
  uint32_t vertex_count_;
  uint32_t base_index_;
  uint32_t index_count_;
  uint16_t base_subset_;
  uint16_t subset_count_;
  uint8_t vertex_format_;
  int8_t padding0__;
  uint16_t vertex_stride_;

 public:
  SubmeshFb() {
    memset(this, 0, sizeof(SubmeshFb));
  }
  SubmeshFb(const Vec3Fb &_bbox_min, const Vec3Fb &_bbox_max, const Vec3Fb &_position_offset, const Vec3Fb &_position_scale, const Vec2Fb &_uv_offset, const Vec2Fb &_uv_scale, uint32_t _base_vertex, uint32_t _vertex_count, uint32_t _base_index, uint32_t _index_count, uint16_t _base_subset, uint16_t _subset_count, EVertexFormatFb _vertex_format, uint16_t _vertex_stride)
      : bbox_min_(_bbox_min),
        bbox_max_(_bbox_max),
        position_offset_(_position_offset),
        position_scale_(_position_scale),
        uv_offset_(_uv_offset),
        uv_scale_(_uv_scale),
        base_vertex_(flatbuffers::EndianScalar(_base_vertex)),
        vertex_count_(flatbuffers::EndianScalar(_vertex_count)),
        base_index_(flatbuffers::EndianScalar(_base_index)),
        index_count_(flatbuffers::EndianScalar(_index_count)),
        base_subset_(flatbuffers::EndianScalar(_base_subset)),
        subset_count_(flatbuffers::EndianScalar(_subset_count)),
        vertex_format_(flatbuffers::EndianScalar(static_cast<uint8_t>(_vertex_format))),
        padding0__(0),
        vertex_stride_(flatbuffers::EndianScalar(_vertex_stride)) {
    (void)padding0__;
  }
  const Vec3Fb &bbox_min() const {
    return bbox_min_;
  }
  Vec3Fb &mutable_bbox_min() {
    return bbox_min_;
  }
  const Vec3Fb &bbox_max() const {
    return bbox_max_;
  }
  Vec3Fb &mutable_bbox_max() {
    return bbox_max_;
  }
  const Vec3Fb &position_offset() const {
    return position_offset_;
  }
  Vec3Fb &mutable_position_offset() {
    return position_offset_;
  }
  const Vec3Fb &position_scale() const {
    return position_scale_;
  }
  Vec3Fb &mutable_position_scale() {
    return position_scale_;
  }
  const Vec2Fb &uv_offset() const {
    return uv_offset_;
  }
  Vec2Fb &mutable_uv_offset() {
    return uv_offset_;
  }
  const Vec2Fb &uv_scale() const {
    return uv_scale_;
  }
  Vec2Fb &mutable_uv_scale() {
    return uv_scale_;
  }
  uint32_t base_vertex() const {
    return flatbuffers::EndianScalar(base_vertex_);
  }
  void mutate_base_vertex(uint32_t _base_vertex) {
    flatbuffers::WriteScalar(&base_vertex_, _base_vertex);
  }
  uint32_t vertex_count() const {
    return flatbuffers::EndianScalar(vertex_count_);
  }
  void mutate_vertex_count(uint32_t _vertex_count) {
    flatbuffers::WriteScalar(&vertex_count_, _vertex_count);
  }
  uint32_t base_index() const {
    return flatbuffers::EndianScalar(base_index_);
  }
  void mutate_base_index(uint32_t _base_index) {
    flatbuffers::WriteScalar(&base_index_, _base_index);
  }
  uint32_t index_count() const {
    return flatbuffers::EndianScalar(index_count_);
  }
  void mutate_index_count(uint32_t _index_count) {
    flatbuffers::WriteScalar(&index_count_, _index_count);
  }
  uint16_t base_subset() const {
    return flatbuffers::EndianScalar(base_subset_);
  }
  void mutate_base_subset(uint16_t _base_subset) {
    flatbuffers::WriteScalar(&base_subset_, _base_subset);
  }
  uint16_t subset_count() const {
    return flatbuffers::EndianScalar(subset_count_);
  }
  void mutate_subset_count(uint16_t _subset_count) {
    flatbuffers::WriteScalar(&subset_count_, _subset_count);
  }
  EVertexFormatFb vertex_format() const {
    return static_cast<EVertexFormatFb>(flatbuffers::EndianScalar(vertex_format_));
  }
  void mutate_vertex_format(EVertexFormatFb _vertex_format) {
    flatbuffers::WriteScalar(&vertex_format_, static_cast<uint8_t>(_vertex_format));
  }
  uint16_t vertex_stride() const {
    return flatbuffers::EndianScalar(vertex_stride_);
  }
  void mutate_vertex_stride(uint16_t _vertex_stride) {
    flatbuffers::WriteScalar(&vertex_stride_, _vertex_stride);
  }
};
STRUCT_END(SubmeshFb, 88);

MANUALLY_ALIGNED_STRUCT(4) SubsetFb FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t material_id_;
  uint32_t base_index_;
  uint32_t index_count_;

 public:
  SubsetFb() {
    memset(this, 0, sizeof(SubsetFb));
  }
  SubsetFb(uint32_t _material_id, uint32_t _base_index, uint32_t _index_count)
      : material_id_(flatbuffers::EndianScalar(_material_id)),
        base_index_(flatbuffers::EndianScalar(_base_index)),
        index_count_(flatbuffers::EndianScalar(_index_count)) {
  }
  uint32_t material_id() const {
    return flatbuffers::EndianScalar(material_id_);
  }
  void mutate_material_id(uint32_t _material_id) {
    flatbuffers::WriteScalar(&material_id_, _material_id);
  }
  uint32_t base_index() const {
    return flatbuffers::EndianScalar(base_index_);
  }
  void mutate_base_index(uint32_t _base_index) {
    flatbuffers::WriteScalar(&base_index_, _base_index);
  }
  uint32_t index_count() const {
    return flatbuffers::EndianScalar(index_count_);
  }
  void mutate_index_count(uint32_t _index_count) {
    flatbuffers::WriteScalar(&index_count_, _index_count);
  }
};
STRUCT_END(SubsetFb, 12);

MANUALLY_ALIGNED_STRUCT(4) TransformFb FLATBUFFERS_FINAL_CLASS {
 private:
  Vec3Fb translation_;
  Vec3Fb rotation_offset_;
  Vec3Fb rotation_pivot_;
  Vec3Fb pre_rotation_;
  Vec3Fb post_rotation_;
  Vec3Fb rotation_;
  Vec3Fb scaling_offset_;
  Vec3Fb scaling_pivot_;
  Vec3Fb scaling_;
  Vec3Fb geometric_translation_;
  Vec3Fb geometric_rotation_;
  Vec3Fb geometric_scaling_;

 public:
  TransformFb() {
    memset(this, 0, sizeof(TransformFb));
  }
  TransformFb(const Vec3Fb &_translation, const Vec3Fb &_rotation_offset, const Vec3Fb &_rotation_pivot, const Vec3Fb &_pre_rotation, const Vec3Fb &_post_rotation, const Vec3Fb &_rotation, const Vec3Fb &_scaling_offset, const Vec3Fb &_scaling_pivot, const Vec3Fb &_scaling, const Vec3Fb &_geometric_translation, const Vec3Fb &_geometric_rotation, const Vec3Fb &_geometric_scaling)
      : translation_(_translation),
        rotation_offset_(_rotation_offset),
        rotation_pivot_(_rotation_pivot),
        pre_rotation_(_pre_rotation),
        post_rotation_(_post_rotation),
        rotation_(_rotation),
        scaling_offset_(_scaling_offset),
        scaling_pivot_(_scaling_pivot),
        scaling_(_scaling),
        geometric_translation_(_geometric_translation),
        geometric_rotation_(_geometric_rotation),
        geometric_scaling_(_geometric_scaling) {
  }
  const Vec3Fb &translation() const {
    return translation_;
  }
  Vec3Fb &mutable_translation() {
    return translation_;
  }
  const Vec3Fb &rotation_offset() const {
    return rotation_offset_;
  }
  Vec3Fb &mutable_rotation_offset() {
    return rotation_offset_;
  }
  const Vec3Fb &rotation_pivot() const {
    return rotation_pivot_;
  }
  Vec3Fb &mutable_rotation_pivot() {
    return rotation_pivot_;
  }
  const Vec3Fb &pre_rotation() const {
    return pre_rotation_;
  }
  Vec3Fb &mutable_pre_rotation() {
    return pre_rotation_;
  }
  const Vec3Fb &post_rotation() const {
    return post_rotation_;
  }
  Vec3Fb &mutable_post_rotation() {
    return post_rotation_;
  }
  const Vec3Fb &rotation() const {
    return rotation_;
  }
  Vec3Fb &mutable_rotation() {
    return rotation_;
  }
  const Vec3Fb &scaling_offset() const {
    return scaling_offset_;
  }
  Vec3Fb &mutable_scaling_offset() {
    return scaling_offset_;
  }
  const Vec3Fb &scaling_pivot() const {
    return scaling_pivot_;
  }
  Vec3Fb &mutable_scaling_pivot() {
    return scaling_pivot_;
  }
  const Vec3Fb &scaling() const {
    return scaling_;
  }
  Vec3Fb &mutable_scaling() {
    return scaling_;
  }
  const Vec3Fb &geometric_translation() const {
    return geometric_translation_;
  }
  Vec3Fb &mutable_geometric_translation() {
    return geometric_translation_;
  }
  const Vec3Fb &geometric_rotation() const {
    return geometric_rotation_;
  }
  Vec3Fb &mutable_geometric_rotation() {
    return geometric_rotation_;
  }
  const Vec3Fb &geometric_scaling() const {
    return geometric_scaling_;
  }
  Vec3Fb &mutable_geometric_scaling() {
    return geometric_scaling_;
  }
};
STRUCT_END(TransformFb, 144);

MANUALLY_ALIGNED_STRUCT(4) MaterialPropFb FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t name_id_;
  uint32_t value_id_;

 public:
  MaterialPropFb() {
    memset(this, 0, sizeof(MaterialPropFb));
  }
  MaterialPropFb(uint32_t _name_id, uint32_t _value_id)
      : name_id_(flatbuffers::EndianScalar(_name_id)),
        value_id_(flatbuffers::EndianScalar(_value_id)) {
  }
  uint32_t name_id() const {
    return flatbuffers::EndianScalar(name_id_);
  }
  void mutate_name_id(uint32_t _name_id) {
    flatbuffers::WriteScalar(&name_id_, _name_id);
  }
  bool KeyCompareLessThan(const MaterialPropFb *o) const {
    return name_id() < o->name_id();
  }
  int KeyCompareWithValue(uint32_t val) const {
    const auto key = name_id();
    return static_cast<int>(key > val) - static_cast<int>(key < val);
  }
  uint32_t value_id() const {
    return flatbuffers::EndianScalar(value_id_);
  }
  void mutate_value_id(uint32_t _value_id) {
    flatbuffers::WriteScalar(&value_id_, _value_id);
  }
};
STRUCT_END(MaterialPropFb, 8);

MANUALLY_ALIGNED_STRUCT(4) CameraFb FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t id_;
  uint32_t name_id_;
  Vec3Fb up_;
  Vec2Fb aspect_;

 public:
  CameraFb() {
    memset(this, 0, sizeof(CameraFb));
  }
  CameraFb(uint32_t _id, uint32_t _name_id, const Vec3Fb &_up, const Vec2Fb &_aspect)
      : id_(flatbuffers::EndianScalar(_id)),
        name_id_(flatbuffers::EndianScalar(_name_id)),
        up_(_up),
        aspect_(_aspect) {
  }
  uint32_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
  void mutate_id(uint32_t _id) {
    flatbuffers::WriteScalar(&id_, _id);
  }
  uint32_t name_id() const {
    return flatbuffers::EndianScalar(name_id_);
  }
  void mutate_name_id(uint32_t _name_id) {
    flatbuffers::WriteScalar(&name_id_, _name_id);
  }
  bool KeyCompareLessThan(const CameraFb *o) const {
    return name_id() < o->name_id();
  }
  int KeyCompareWithValue(uint32_t val) const {
    const auto key = name_id();
    return static_cast<int>(key > val) - static_cast<int>(key < val);
  }
  const Vec3Fb &up() const {
    return up_;
  }
  Vec3Fb &mutable_up() {
    return up_;
  }
  const Vec2Fb &aspect() const {
    return aspect_;
  }
  Vec2Fb &mutable_aspect() {
    return aspect_;
  }
};
STRUCT_END(CameraFb, 28);

MANUALLY_ALIGNED_STRUCT(4) LightFb FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t id_;
  uint32_t name_id_;
  uint8_t light_type_;
  uint8_t area_light_type_;
  int16_t padding0__;
  Vec3Fb color_;
  float fog_;
  float intensity_;
  float inner_angle_;
  float near_attenuation_start_;
  float near_attenuation_end_;
  float far_attenuation_start_;
  float far_attenuation_end_;
  float outer_angle_;
  float decay_start_;
  uint8_t casts_shadows_;
  int8_t padding1__;  int16_t padding2__;

 public:
  LightFb() {
    memset(this, 0, sizeof(LightFb));
  }
  LightFb(uint32_t _id, uint32_t _name_id, ELightTypeFb _light_type, EAreaLightTypeFb _area_light_type, const Vec3Fb &_color, float _fog, float _intensity, float _inner_angle, float _near_attenuation_start, float _near_attenuation_end, float _far_attenuation_start, float _far_attenuation_end, float _outer_angle, float _decay_start, bool _casts_shadows)
      : id_(flatbuffers::EndianScalar(_id)),
        name_id_(flatbuffers::EndianScalar(_name_id)),
        light_type_(flatbuffers::EndianScalar(static_cast<uint8_t>(_light_type))),
        area_light_type_(flatbuffers::EndianScalar(static_cast<uint8_t>(_area_light_type))),
        padding0__(0),
        color_(_color),
        fog_(flatbuffers::EndianScalar(_fog)),
        intensity_(flatbuffers::EndianScalar(_intensity)),
        inner_angle_(flatbuffers::EndianScalar(_inner_angle)),
        near_attenuation_start_(flatbuffers::EndianScalar(_near_attenuation_start)),
        near_attenuation_end_(flatbuffers::EndianScalar(_near_attenuation_end)),
        far_attenuation_start_(flatbuffers::EndianScalar(_far_attenuation_start)),
        far_attenuation_end_(flatbuffers::EndianScalar(_far_attenuation_end)),
        outer_angle_(flatbuffers::EndianScalar(_outer_angle)),
        decay_start_(flatbuffers::EndianScalar(_decay_start)),
        casts_shadows_(flatbuffers::EndianScalar(static_cast<uint8_t>(_casts_shadows))),
        padding1__(0),
        padding2__(0) {
    (void)padding0__;
    (void)padding1__;    (void)padding2__;
  }
  uint32_t id() const {
    return flatbuffers::EndianScalar(id_);
  }
  void mutate_id(uint32_t _id) {
    flatbuffers::WriteScalar(&id_, _id);
  }
  uint32_t name_id() const {
    return flatbuffers::EndianScalar(name_id_);
  }
  void mutate_name_id(uint32_t _name_id) {
    flatbuffers::WriteScalar(&name_id_, _name_id);
  }
  bool KeyCompareLessThan(const LightFb *o) const {
    return name_id() < o->name_id();
  }
  int KeyCompareWithValue(uint32_t val) const {
    const auto key = name_id();
    return static_cast<int>(key > val) - static_cast<int>(key < val);
  }
  ELightTypeFb light_type() const {
    return static_cast<ELightTypeFb>(flatbuffers::EndianScalar(light_type_));
  }
  void mutate_light_type(ELightTypeFb _light_type) {
    flatbuffers::WriteScalar(&light_type_, static_cast<uint8_t>(_light_type));
  }
  EAreaLightTypeFb area_light_type() const {
    return static_cast<EAreaLightTypeFb>(flatbuffers::EndianScalar(area_light_type_));
  }
  void mutate_area_light_type(EAreaLightTypeFb _area_light_type) {
    flatbuffers::WriteScalar(&area_light_type_, static_cast<uint8_t>(_area_light_type));
  }
  const Vec3Fb &color() const {
    return color_;
  }
  Vec3Fb &mutable_color() {
    return color_;
  }
  float fog() const {
    return flatbuffers::EndianScalar(fog_);
  }
  void mutate_fog(float _fog) {
    flatbuffers::WriteScalar(&fog_, _fog);
  }
  float intensity() const {
    return flatbuffers::EndianScalar(intensity_);
  }
  void mutate_intensity(float _intensity) {
    flatbuffers::WriteScalar(&intensity_, _intensity);
  }
  float inner_angle() const {
    return flatbuffers::EndianScalar(inner_angle_);
  }
  void mutate_inner_angle(float _inner_angle) {
    flatbuffers::WriteScalar(&inner_angle_, _inner_angle);
  }
  float near_attenuation_start() const {
    return flatbuffers::EndianScalar(near_attenuation_start_);
  }
  void mutate_near_attenuation_start(float _near_attenuation_start) {
    flatbuffers::WriteScalar(&near_attenuation_start_, _near_attenuation_start);
  }
  float near_attenuation_end() const {
    return flatbuffers::EndianScalar(near_attenuation_end_);
  }
  void mutate_near_attenuation_end(float _near_attenuation_end) {
    flatbuffers::WriteScalar(&near_attenuation_end_, _near_attenuation_end);
  }
  float far_attenuation_start() const {
    return flatbuffers::EndianScalar(far_attenuation_start_);
  }
  void mutate_far_attenuation_start(float _far_attenuation_start) {
    flatbuffers::WriteScalar(&far_attenuation_start_, _far_attenuation_start);
  }
  float far_attenuation_end() const {
    return flatbuffers::EndianScalar(far_attenuation_end_);
  }
  void mutate_far_attenuation_end(float _far_attenuation_end) {
    flatbuffers::WriteScalar(&far_attenuation_end_, _far_attenuation_end);
  }
  float outer_angle() const {
    return flatbuffers::EndianScalar(outer_angle_);
  }
  void mutate_outer_angle(float _outer_angle) {
    flatbuffers::WriteScalar(&outer_angle_, _outer_angle);
  }
  float decay_start() const {
    return flatbuffers::EndianScalar(decay_start_);
  }
  void mutate_decay_start(float _decay_start) {
    flatbuffers::WriteScalar(&decay_start_, _decay_start);
  }
  bool casts_shadows() const {
    return flatbuffers::EndianScalar(casts_shadows_) != 0;
  }
  void mutate_casts_shadows(bool _casts_shadows) {
    flatbuffers::WriteScalar(&casts_shadows_, static_cast<uint8_t>(_casts_shadows));
  }
};
STRUCT_END(LightFb, 64);

struct AnimCurveFb FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_NAME_ID = 6,
    VT_PROPERTY = 8,
    VT_CHANNEL = 10,
    VT_KEYS = 12
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool mutate_id(uint32_t _id) {
    return SetField<uint32_t>(VT_ID, _id, 0);
  }
  uint32_t name_id() const {
    return GetField<uint32_t>(VT_NAME_ID, 0);
  }
  bool mutate_name_id(uint32_t _name_id) {
    return SetField<uint32_t>(VT_NAME_ID, _name_id, 0);
  }
  bool KeyCompareLessThan(const AnimCurveFb *o) const {
    return name_id() < o->name_id();
  }
  int KeyCompareWithValue(uint32_t val) const {
    const auto key = name_id();
    if (key < val) {
      return -1;
    } else if (key > val) {
      return 1;
    } else {
      return 0;
    }
  }
  EAnimCurvePropertyFb property() const {
    return static_cast<EAnimCurvePropertyFb>(GetField<uint8_t>(VT_PROPERTY, 0));
  }
  bool mutate_property(EAnimCurvePropertyFb _property) {
    return SetField<uint8_t>(VT_PROPERTY, static_cast<uint8_t>(_property), 0);
  }
  EAnimCurveChannelFb channel() const {
    return static_cast<EAnimCurveChannelFb>(GetField<uint8_t>(VT_CHANNEL, 0));
  }
  bool mutate_channel(EAnimCurveChannelFb _channel) {
    return SetField<uint8_t>(VT_CHANNEL, static_cast<uint8_t>(_channel), 0);
  }
  const flatbuffers::Vector<const AnimCurveKeyFb *> *keys() const {
    return GetPointer<const flatbuffers::Vector<const AnimCurveKeyFb *> *>(VT_KEYS);
  }
  flatbuffers::Vector<const AnimCurveKeyFb *> *mutable_keys() {
    return GetPointer<flatbuffers::Vector<const AnimCurveKeyFb *> *>(VT_KEYS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyField<uint32_t>(verifier, VT_NAME_ID) &&
           VerifyField<uint8_t>(verifier, VT_PROPERTY) &&
           VerifyField<uint8_t>(verifier, VT_CHANNEL) &&
           VerifyOffset(verifier, VT_KEYS) &&
           verifier.Verify(keys()) &&
           verifier.EndTable();
  }
};

struct AnimCurveFbBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(AnimCurveFb::VT_ID, id, 0);
  }
  void add_name_id(uint32_t name_id) {
    fbb_.AddElement<uint32_t>(AnimCurveFb::VT_NAME_ID, name_id, 0);
  }
  void add_property(EAnimCurvePropertyFb property) {
    fbb_.AddElement<uint8_t>(AnimCurveFb::VT_PROPERTY, static_cast<uint8_t>(property), 0);
  }
  void add_channel(EAnimCurveChannelFb channel) {
    fbb_.AddElement<uint8_t>(AnimCurveFb::VT_CHANNEL, static_cast<uint8_t>(channel), 0);
  }
  void add_keys(flatbuffers::Offset<flatbuffers::Vector<const AnimCurveKeyFb *>> keys) {
    fbb_.AddOffset(AnimCurveFb::VT_KEYS, keys);
  }
  explicit AnimCurveFbBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AnimCurveFbBuilder &operator=(const AnimCurveFbBuilder &);
  flatbuffers::Offset<AnimCurveFb> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AnimCurveFb>(end);
    return o;
  }
};

inline flatbuffers::Offset<AnimCurveFb> CreateAnimCurveFb(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint32_t name_id = 0,
    EAnimCurvePropertyFb property = EAnimCurvePropertyFb_LclTranslation,
    EAnimCurveChannelFb channel = EAnimCurveChannelFb_X,
    flatbuffers::Offset<flatbuffers::Vector<const AnimCurveKeyFb *>> keys = 0) {
  AnimCurveFbBuilder builder_(_fbb);
  builder_.add_keys(keys);
  builder_.add_name_id(name_id);
  builder_.add_id(id);
  builder_.add_channel(channel);
  builder_.add_property(property);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimCurveFb> CreateAnimCurveFbDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint32_t name_id = 0,
    EAnimCurvePropertyFb property = EAnimCurvePropertyFb_LclTranslation,
    EAnimCurveChannelFb channel = EAnimCurveChannelFb_X,
    const std::vector<const AnimCurveKeyFb *> *keys = nullptr) {
  return apemodefb::CreateAnimCurveFb(
      _fbb,
      id,
      name_id,
      property,
      channel,
      keys ? _fbb.CreateVector<const AnimCurveKeyFb *>(*keys) : 0);
}

struct NameFb FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_H = 4,
    VT_V = 6
  };
  uint64_t h() const {
    return GetField<uint64_t>(VT_H, 0);
  }
  bool mutate_h(uint64_t _h) {
    return SetField<uint64_t>(VT_H, _h, 0);
  }
  bool KeyCompareLessThan(const NameFb *o) const {
    return h() < o->h();
  }
  int KeyCompareWithValue(uint64_t val) const {
    const auto key = h();
    if (key < val) {
      return -1;
    } else if (key > val) {
      return 1;
    } else {
      return 0;
    }
  }
  const flatbuffers::String *v() const {
    return GetPointer<const flatbuffers::String *>(VT_V);
  }
  flatbuffers::String *mutable_v() {
    return GetPointer<flatbuffers::String *>(VT_V);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_H) &&
           VerifyOffset(verifier, VT_V) &&
           verifier.Verify(v()) &&
           verifier.EndTable();
  }
};

struct NameFbBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_h(uint64_t h) {
    fbb_.AddElement<uint64_t>(NameFb::VT_H, h, 0);
  }
  void add_v(flatbuffers::Offset<flatbuffers::String> v) {
    fbb_.AddOffset(NameFb::VT_V, v);
  }
  explicit NameFbBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NameFbBuilder &operator=(const NameFbBuilder &);
  flatbuffers::Offset<NameFb> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NameFb>(end);
    return o;
  }
};

inline flatbuffers::Offset<NameFb> CreateNameFb(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t h = 0,
    flatbuffers::Offset<flatbuffers::String> v = 0) {
  NameFbBuilder builder_(_fbb);
  builder_.add_h(h);
  builder_.add_v(v);
  return builder_.Finish();
}

inline flatbuffers::Offset<NameFb> CreateNameFbDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t h = 0,
    const char *v = nullptr) {
  return apemodefb::CreateNameFb(
      _fbb,
      h,
      v ? _fbb.CreateString(v) : 0);
}

struct SkinFb FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME_ID = 4,
    VT_LINKS_IDS = 6
  };
  uint32_t name_id() const {
    return GetField<uint32_t>(VT_NAME_ID, 0);
  }
  bool mutate_name_id(uint32_t _name_id) {
    return SetField<uint32_t>(VT_NAME_ID, _name_id, 0);
  }
  bool KeyCompareLessThan(const SkinFb *o) const {
    return name_id() < o->name_id();
  }
  int KeyCompareWithValue(uint32_t val) const {
    const auto key = name_id();
    if (key < val) {
      return -1;
    } else if (key > val) {
      return 1;
    } else {
      return 0;
    }
  }
  const flatbuffers::Vector<uint32_t> *links_ids() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_LINKS_IDS);
  }
  flatbuffers::Vector<uint32_t> *mutable_links_ids() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_LINKS_IDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_NAME_ID) &&
           VerifyOffset(verifier, VT_LINKS_IDS) &&
           verifier.Verify(links_ids()) &&
           verifier.EndTable();
  }
};

struct SkinFbBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name_id(uint32_t name_id) {
    fbb_.AddElement<uint32_t>(SkinFb::VT_NAME_ID, name_id, 0);
  }
  void add_links_ids(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> links_ids) {
    fbb_.AddOffset(SkinFb::VT_LINKS_IDS, links_ids);
  }
  explicit SkinFbBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkinFbBuilder &operator=(const SkinFbBuilder &);
  flatbuffers::Offset<SkinFb> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkinFb>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkinFb> CreateSkinFb(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t name_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> links_ids = 0) {
  SkinFbBuilder builder_(_fbb);
  builder_.add_links_ids(links_ids);
  builder_.add_name_id(name_id);
  return builder_.Finish();
}

inline flatbuffers::Offset<SkinFb> CreateSkinFbDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t name_id = 0,
    const std::vector<uint32_t> *links_ids = nullptr) {
  return apemodefb::CreateSkinFb(
      _fbb,
      name_id,
      links_ids ? _fbb.CreateVector<uint32_t>(*links_ids) : 0);
}

struct MeshFb FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VERTICES = 4,
    VT_SUBMESHES = 6,
    VT_SUBSETS = 8,
    VT_INDICES = 10,
    VT_INDEX_TYPE = 12,
    VT_SKIN_ID = 14
  };
  const flatbuffers::Vector<uint8_t> *vertices() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VERTICES);
  }
  flatbuffers::Vector<uint8_t> *mutable_vertices() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_VERTICES);
  }
  const flatbuffers::Vector<const SubmeshFb *> *submeshes() const {
    return GetPointer<const flatbuffers::Vector<const SubmeshFb *> *>(VT_SUBMESHES);
  }
  flatbuffers::Vector<const SubmeshFb *> *mutable_submeshes() {
    return GetPointer<flatbuffers::Vector<const SubmeshFb *> *>(VT_SUBMESHES);
  }
  const flatbuffers::Vector<const SubsetFb *> *subsets() const {
    return GetPointer<const flatbuffers::Vector<const SubsetFb *> *>(VT_SUBSETS);
  }
  flatbuffers::Vector<const SubsetFb *> *mutable_subsets() {
    return GetPointer<flatbuffers::Vector<const SubsetFb *> *>(VT_SUBSETS);
  }
  const flatbuffers::Vector<uint8_t> *indices() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_INDICES);
  }
  flatbuffers::Vector<uint8_t> *mutable_indices() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_INDICES);
  }
  EIndexTypeFb index_type() const {
    return static_cast<EIndexTypeFb>(GetField<uint8_t>(VT_INDEX_TYPE, 0));
  }
  bool mutate_index_type(EIndexTypeFb _index_type) {
    return SetField<uint8_t>(VT_INDEX_TYPE, static_cast<uint8_t>(_index_type), 0);
  }
  uint32_t skin_id() const {
    return GetField<uint32_t>(VT_SKIN_ID, 0);
  }
  bool mutate_skin_id(uint32_t _skin_id) {
    return SetField<uint32_t>(VT_SKIN_ID, _skin_id, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_VERTICES) &&
           verifier.Verify(vertices()) &&
           VerifyOffset(verifier, VT_SUBMESHES) &&
           verifier.Verify(submeshes()) &&
           VerifyOffset(verifier, VT_SUBSETS) &&
           verifier.Verify(subsets()) &&
           VerifyOffset(verifier, VT_INDICES) &&
           verifier.Verify(indices()) &&
           VerifyField<uint8_t>(verifier, VT_INDEX_TYPE) &&
           VerifyField<uint32_t>(verifier, VT_SKIN_ID) &&
           verifier.EndTable();
  }
};

struct MeshFbBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_vertices(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> vertices) {
    fbb_.AddOffset(MeshFb::VT_VERTICES, vertices);
  }
  void add_submeshes(flatbuffers::Offset<flatbuffers::Vector<const SubmeshFb *>> submeshes) {
    fbb_.AddOffset(MeshFb::VT_SUBMESHES, submeshes);
  }
  void add_subsets(flatbuffers::Offset<flatbuffers::Vector<const SubsetFb *>> subsets) {
    fbb_.AddOffset(MeshFb::VT_SUBSETS, subsets);
  }
  void add_indices(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> indices) {
    fbb_.AddOffset(MeshFb::VT_INDICES, indices);
  }
  void add_index_type(EIndexTypeFb index_type) {
    fbb_.AddElement<uint8_t>(MeshFb::VT_INDEX_TYPE, static_cast<uint8_t>(index_type), 0);
  }
  void add_skin_id(uint32_t skin_id) {
    fbb_.AddElement<uint32_t>(MeshFb::VT_SKIN_ID, skin_id, 0);
  }
  explicit MeshFbBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MeshFbBuilder &operator=(const MeshFbBuilder &);
  flatbuffers::Offset<MeshFb> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MeshFb>(end);
    return o;
  }
};

inline flatbuffers::Offset<MeshFb> CreateMeshFb(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> vertices = 0,
    flatbuffers::Offset<flatbuffers::Vector<const SubmeshFb *>> submeshes = 0,
    flatbuffers::Offset<flatbuffers::Vector<const SubsetFb *>> subsets = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> indices = 0,
    EIndexTypeFb index_type = EIndexTypeFb_UInt16,
    uint32_t skin_id = 0) {
  MeshFbBuilder builder_(_fbb);
  builder_.add_skin_id(skin_id);
  builder_.add_indices(indices);
  builder_.add_subsets(subsets);
  builder_.add_submeshes(submeshes);
  builder_.add_vertices(vertices);
  builder_.add_index_type(index_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<MeshFb> CreateMeshFbDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *vertices = nullptr,
    const std::vector<const SubmeshFb *> *submeshes = nullptr,
    const std::vector<const SubsetFb *> *subsets = nullptr,
    const std::vector<uint8_t> *indices = nullptr,
    EIndexTypeFb index_type = EIndexTypeFb_UInt16,
    uint32_t skin_id = 0) {
  return apemodefb::CreateMeshFb(
      _fbb,
      vertices ? _fbb.CreateVector<uint8_t>(*vertices) : 0,
      submeshes ? _fbb.CreateVector<const SubmeshFb *>(*submeshes) : 0,
      subsets ? _fbb.CreateVector<const SubsetFb *>(*subsets) : 0,
      indices ? _fbb.CreateVector<uint8_t>(*indices) : 0,
      index_type,
      skin_id);
}

struct MaterialFb FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_NAME_ID = 6,
    VT_PROPERTIES = 8,
    VT_TEXTURE_PROPERTIES = 10
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool mutate_id(uint32_t _id) {
    return SetField<uint32_t>(VT_ID, _id, 0);
  }
  uint32_t name_id() const {
    return GetField<uint32_t>(VT_NAME_ID, 0);
  }
  bool mutate_name_id(uint32_t _name_id) {
    return SetField<uint32_t>(VT_NAME_ID, _name_id, 0);
  }
  bool KeyCompareLessThan(const MaterialFb *o) const {
    return name_id() < o->name_id();
  }
  int KeyCompareWithValue(uint32_t val) const {
    const auto key = name_id();
    if (key < val) {
      return -1;
    } else if (key > val) {
      return 1;
    } else {
      return 0;
    }
  }
  const flatbuffers::Vector<const MaterialPropFb *> *properties() const {
    return GetPointer<const flatbuffers::Vector<const MaterialPropFb *> *>(VT_PROPERTIES);
  }
  flatbuffers::Vector<const MaterialPropFb *> *mutable_properties() {
    return GetPointer<flatbuffers::Vector<const MaterialPropFb *> *>(VT_PROPERTIES);
  }
  const flatbuffers::Vector<const MaterialPropFb *> *texture_properties() const {
    return GetPointer<const flatbuffers::Vector<const MaterialPropFb *> *>(VT_TEXTURE_PROPERTIES);
  }
  flatbuffers::Vector<const MaterialPropFb *> *mutable_texture_properties() {
    return GetPointer<flatbuffers::Vector<const MaterialPropFb *> *>(VT_TEXTURE_PROPERTIES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyField<uint32_t>(verifier, VT_NAME_ID) &&
           VerifyOffset(verifier, VT_PROPERTIES) &&
           verifier.Verify(properties()) &&
           VerifyOffset(verifier, VT_TEXTURE_PROPERTIES) &&
           verifier.Verify(texture_properties()) &&
           verifier.EndTable();
  }
};

struct MaterialFbBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(MaterialFb::VT_ID, id, 0);
  }
  void add_name_id(uint32_t name_id) {
    fbb_.AddElement<uint32_t>(MaterialFb::VT_NAME_ID, name_id, 0);
  }
  void add_properties(flatbuffers::Offset<flatbuffers::Vector<const MaterialPropFb *>> properties) {
    fbb_.AddOffset(MaterialFb::VT_PROPERTIES, properties);
  }
  void add_texture_properties(flatbuffers::Offset<flatbuffers::Vector<const MaterialPropFb *>> texture_properties) {
    fbb_.AddOffset(MaterialFb::VT_TEXTURE_PROPERTIES, texture_properties);
  }
  explicit MaterialFbBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaterialFbBuilder &operator=(const MaterialFbBuilder &);
  flatbuffers::Offset<MaterialFb> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaterialFb>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaterialFb> CreateMaterialFb(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint32_t name_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<const MaterialPropFb *>> properties = 0,
    flatbuffers::Offset<flatbuffers::Vector<const MaterialPropFb *>> texture_properties = 0) {
  MaterialFbBuilder builder_(_fbb);
  builder_.add_texture_properties(texture_properties);
  builder_.add_properties(properties);
  builder_.add_name_id(name_id);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<MaterialFb> CreateMaterialFbDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint32_t name_id = 0,
    const std::vector<const MaterialPropFb *> *properties = nullptr,
    const std::vector<const MaterialPropFb *> *texture_properties = nullptr) {
  return apemodefb::CreateMaterialFb(
      _fbb,
      id,
      name_id,
      properties ? _fbb.CreateVector<const MaterialPropFb *>(*properties) : 0,
      texture_properties ? _fbb.CreateVector<const MaterialPropFb *>(*texture_properties) : 0);
}

struct NodeFb FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_MESH_ID = 6,
    VT_LIGHT_ID = 8,
    VT_CAMERA_ID = 10,
    VT_NAME_ID = 12,
    VT_CULLING_TYPE = 14,
    VT_CHILD_IDS = 16,
    VT_ANIM_CURVE_IDS = 18
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool mutate_id(uint32_t _id) {
    return SetField<uint32_t>(VT_ID, _id, 0);
  }
  uint32_t mesh_id() const {
    return GetField<uint32_t>(VT_MESH_ID, 0);
  }
  bool mutate_mesh_id(uint32_t _mesh_id) {
    return SetField<uint32_t>(VT_MESH_ID, _mesh_id, 0);
  }
  uint32_t light_id() const {
    return GetField<uint32_t>(VT_LIGHT_ID, 0);
  }
  bool mutate_light_id(uint32_t _light_id) {
    return SetField<uint32_t>(VT_LIGHT_ID, _light_id, 0);
  }
  uint32_t camera_id() const {
    return GetField<uint32_t>(VT_CAMERA_ID, 0);
  }
  bool mutate_camera_id(uint32_t _camera_id) {
    return SetField<uint32_t>(VT_CAMERA_ID, _camera_id, 0);
  }
  uint32_t name_id() const {
    return GetField<uint32_t>(VT_NAME_ID, 0);
  }
  bool mutate_name_id(uint32_t _name_id) {
    return SetField<uint32_t>(VT_NAME_ID, _name_id, 0);
  }
  bool KeyCompareLessThan(const NodeFb *o) const {
    return name_id() < o->name_id();
  }
  int KeyCompareWithValue(uint32_t val) const {
    const auto key = name_id();
    if (key < val) {
      return -1;
    } else if (key > val) {
      return 1;
    } else {
      return 0;
    }
  }
  ECullingTypeFb culling_type() const {
    return static_cast<ECullingTypeFb>(GetField<uint8_t>(VT_CULLING_TYPE, 0));
  }
  bool mutate_culling_type(ECullingTypeFb _culling_type) {
    return SetField<uint8_t>(VT_CULLING_TYPE, static_cast<uint8_t>(_culling_type), 0);
  }
  const flatbuffers::Vector<uint32_t> *child_ids() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_CHILD_IDS);
  }
  flatbuffers::Vector<uint32_t> *mutable_child_ids() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_CHILD_IDS);
  }
  const flatbuffers::Vector<uint32_t> *anim_curve_ids() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_ANIM_CURVE_IDS);
  }
  flatbuffers::Vector<uint32_t> *mutable_anim_curve_ids() {
    return GetPointer<flatbuffers::Vector<uint32_t> *>(VT_ANIM_CURVE_IDS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyField<uint32_t>(verifier, VT_MESH_ID) &&
           VerifyField<uint32_t>(verifier, VT_LIGHT_ID) &&
           VerifyField<uint32_t>(verifier, VT_CAMERA_ID) &&
           VerifyField<uint32_t>(verifier, VT_NAME_ID) &&
           VerifyField<uint8_t>(verifier, VT_CULLING_TYPE) &&
           VerifyOffset(verifier, VT_CHILD_IDS) &&
           verifier.Verify(child_ids()) &&
           VerifyOffset(verifier, VT_ANIM_CURVE_IDS) &&
           verifier.Verify(anim_curve_ids()) &&
           verifier.EndTable();
  }
};

struct NodeFbBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(NodeFb::VT_ID, id, 0);
  }
  void add_mesh_id(uint32_t mesh_id) {
    fbb_.AddElement<uint32_t>(NodeFb::VT_MESH_ID, mesh_id, 0);
  }
  void add_light_id(uint32_t light_id) {
    fbb_.AddElement<uint32_t>(NodeFb::VT_LIGHT_ID, light_id, 0);
  }
  void add_camera_id(uint32_t camera_id) {
    fbb_.AddElement<uint32_t>(NodeFb::VT_CAMERA_ID, camera_id, 0);
  }
  void add_name_id(uint32_t name_id) {
    fbb_.AddElement<uint32_t>(NodeFb::VT_NAME_ID, name_id, 0);
  }
  void add_culling_type(ECullingTypeFb culling_type) {
    fbb_.AddElement<uint8_t>(NodeFb::VT_CULLING_TYPE, static_cast<uint8_t>(culling_type), 0);
  }
  void add_child_ids(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> child_ids) {
    fbb_.AddOffset(NodeFb::VT_CHILD_IDS, child_ids);
  }
  void add_anim_curve_ids(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> anim_curve_ids) {
    fbb_.AddOffset(NodeFb::VT_ANIM_CURVE_IDS, anim_curve_ids);
  }
  explicit NodeFbBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NodeFbBuilder &operator=(const NodeFbBuilder &);
  flatbuffers::Offset<NodeFb> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NodeFb>(end);
    return o;
  }
};

inline flatbuffers::Offset<NodeFb> CreateNodeFb(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint32_t mesh_id = 0,
    uint32_t light_id = 0,
    uint32_t camera_id = 0,
    uint32_t name_id = 0,
    ECullingTypeFb culling_type = ECullingTypeFb_CullingOff,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> child_ids = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> anim_curve_ids = 0) {
  NodeFbBuilder builder_(_fbb);
  builder_.add_anim_curve_ids(anim_curve_ids);
  builder_.add_child_ids(child_ids);
  builder_.add_name_id(name_id);
  builder_.add_camera_id(camera_id);
  builder_.add_light_id(light_id);
  builder_.add_mesh_id(mesh_id);
  builder_.add_id(id);
  builder_.add_culling_type(culling_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<NodeFb> CreateNodeFbDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint32_t mesh_id = 0,
    uint32_t light_id = 0,
    uint32_t camera_id = 0,
    uint32_t name_id = 0,
    ECullingTypeFb culling_type = ECullingTypeFb_CullingOff,
    const std::vector<uint32_t> *child_ids = nullptr,
    const std::vector<uint32_t> *anim_curve_ids = nullptr) {
  return apemodefb::CreateNodeFb(
      _fbb,
      id,
      mesh_id,
      light_id,
      camera_id,
      name_id,
      culling_type,
      child_ids ? _fbb.CreateVector<uint32_t>(*child_ids) : 0,
      anim_curve_ids ? _fbb.CreateVector<uint32_t>(*anim_curve_ids) : 0);
}

struct FileFb FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_NAME_ID = 6,
    VT_BUFFER = 8
  };
  uint32_t id() const {
    return GetField<uint32_t>(VT_ID, 0);
  }
  bool mutate_id(uint32_t _id) {
    return SetField<uint32_t>(VT_ID, _id, 0);
  }
  uint32_t name_id() const {
    return GetField<uint32_t>(VT_NAME_ID, 0);
  }
  bool mutate_name_id(uint32_t _name_id) {
    return SetField<uint32_t>(VT_NAME_ID, _name_id, 0);
  }
  bool KeyCompareLessThan(const FileFb *o) const {
    return name_id() < o->name_id();
  }
  int KeyCompareWithValue(uint32_t val) const {
    const auto key = name_id();
    if (key < val) {
      return -1;
    } else if (key > val) {
      return 1;
    } else {
      return 0;
    }
  }
  const flatbuffers::Vector<uint8_t> *buffer() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BUFFER);
  }
  flatbuffers::Vector<uint8_t> *mutable_buffer() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_BUFFER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint32_t>(verifier, VT_ID) &&
           VerifyField<uint32_t>(verifier, VT_NAME_ID) &&
           VerifyOffset(verifier, VT_BUFFER) &&
           verifier.Verify(buffer()) &&
           verifier.EndTable();
  }
};

struct FileFbBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint32_t id) {
    fbb_.AddElement<uint32_t>(FileFb::VT_ID, id, 0);
  }
  void add_name_id(uint32_t name_id) {
    fbb_.AddElement<uint32_t>(FileFb::VT_NAME_ID, name_id, 0);
  }
  void add_buffer(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buffer) {
    fbb_.AddOffset(FileFb::VT_BUFFER, buffer);
  }
  explicit FileFbBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FileFbBuilder &operator=(const FileFbBuilder &);
  flatbuffers::Offset<FileFb> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FileFb>(end);
    return o;
  }
};

inline flatbuffers::Offset<FileFb> CreateFileFb(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint32_t name_id = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> buffer = 0) {
  FileFbBuilder builder_(_fbb);
  builder_.add_buffer(buffer);
  builder_.add_name_id(name_id);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<FileFb> CreateFileFbDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint32_t id = 0,
    uint32_t name_id = 0,
    const std::vector<uint8_t> *buffer = nullptr) {
  return apemodefb::CreateFileFb(
      _fbb,
      id,
      name_id,
      buffer ? _fbb.CreateVector<uint8_t>(*buffer) : 0);
}

struct SceneFb FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VERSION = 4,
    VT_TRANSFORMS = 6,
    VT_NODES = 8,
    VT_MESHES = 10,
    VT_ANIM_STACKS = 12,
    VT_ANIM_LAYERS = 14,
    VT_ANIM_CURVES = 16,
    VT_MATERIALS = 18,
    VT_TEXTURES = 20,
    VT_CAMERAS = 22,
    VT_LIGHTS = 24,
    VT_SKINS = 26,
    VT_FILES = 28,
    VT_BOOL_VALUES = 30,
    VT_INT_VALUES = 32,
    VT_FLOAT_VALUES = 34,
    VT_STRING_VALUES = 36
  };
  EVersionFb version() const {
    return static_cast<EVersionFb>(GetField<uint8_t>(VT_VERSION, 0));
  }
  bool mutate_version(EVersionFb _version) {
    return SetField<uint8_t>(VT_VERSION, static_cast<uint8_t>(_version), 0);
  }
  const flatbuffers::Vector<const TransformFb *> *transforms() const {
    return GetPointer<const flatbuffers::Vector<const TransformFb *> *>(VT_TRANSFORMS);
  }
  flatbuffers::Vector<const TransformFb *> *mutable_transforms() {
    return GetPointer<flatbuffers::Vector<const TransformFb *> *>(VT_TRANSFORMS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<NodeFb>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NodeFb>> *>(VT_NODES);
  }
  flatbuffers::Vector<flatbuffers::Offset<NodeFb>> *mutable_nodes() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<NodeFb>> *>(VT_NODES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MeshFb>> *meshes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MeshFb>> *>(VT_MESHES);
  }
  flatbuffers::Vector<flatbuffers::Offset<MeshFb>> *mutable_meshes() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<MeshFb>> *>(VT_MESHES);
  }
  const flatbuffers::Vector<const AnimStackFb *> *anim_stacks() const {
    return GetPointer<const flatbuffers::Vector<const AnimStackFb *> *>(VT_ANIM_STACKS);
  }
  flatbuffers::Vector<const AnimStackFb *> *mutable_anim_stacks() {
    return GetPointer<flatbuffers::Vector<const AnimStackFb *> *>(VT_ANIM_STACKS);
  }
  const flatbuffers::Vector<const AnimLayerFb *> *anim_layers() const {
    return GetPointer<const flatbuffers::Vector<const AnimLayerFb *> *>(VT_ANIM_LAYERS);
  }
  flatbuffers::Vector<const AnimLayerFb *> *mutable_anim_layers() {
    return GetPointer<flatbuffers::Vector<const AnimLayerFb *> *>(VT_ANIM_LAYERS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<AnimCurveFb>> *anim_curves() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimCurveFb>> *>(VT_ANIM_CURVES);
  }
  flatbuffers::Vector<flatbuffers::Offset<AnimCurveFb>> *mutable_anim_curves() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<AnimCurveFb>> *>(VT_ANIM_CURVES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<MaterialFb>> *materials() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<MaterialFb>> *>(VT_MATERIALS);
  }
  flatbuffers::Vector<flatbuffers::Offset<MaterialFb>> *mutable_materials() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<MaterialFb>> *>(VT_MATERIALS);
  }
  const flatbuffers::Vector<const TextureFb *> *textures() const {
    return GetPointer<const flatbuffers::Vector<const TextureFb *> *>(VT_TEXTURES);
  }
  flatbuffers::Vector<const TextureFb *> *mutable_textures() {
    return GetPointer<flatbuffers::Vector<const TextureFb *> *>(VT_TEXTURES);
  }
  const flatbuffers::Vector<const CameraFb *> *cameras() const {
    return GetPointer<const flatbuffers::Vector<const CameraFb *> *>(VT_CAMERAS);
  }
  flatbuffers::Vector<const CameraFb *> *mutable_cameras() {
    return GetPointer<flatbuffers::Vector<const CameraFb *> *>(VT_CAMERAS);
  }
  const flatbuffers::Vector<const LightFb *> *lights() const {
    return GetPointer<const flatbuffers::Vector<const LightFb *> *>(VT_LIGHTS);
  }
  flatbuffers::Vector<const LightFb *> *mutable_lights() {
    return GetPointer<flatbuffers::Vector<const LightFb *> *>(VT_LIGHTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SkinFb>> *skins() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SkinFb>> *>(VT_SKINS);
  }
  flatbuffers::Vector<flatbuffers::Offset<SkinFb>> *mutable_skins() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<SkinFb>> *>(VT_SKINS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<FileFb>> *files() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<FileFb>> *>(VT_FILES);
  }
  flatbuffers::Vector<flatbuffers::Offset<FileFb>> *mutable_files() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<FileFb>> *>(VT_FILES);
  }
  const flatbuffers::Vector<uint8_t> *bool_values() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BOOL_VALUES);
  }
  flatbuffers::Vector<uint8_t> *mutable_bool_values() {
    return GetPointer<flatbuffers::Vector<uint8_t> *>(VT_BOOL_VALUES);
  }
  const flatbuffers::Vector<int32_t> *int_values() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INT_VALUES);
  }
  flatbuffers::Vector<int32_t> *mutable_int_values() {
    return GetPointer<flatbuffers::Vector<int32_t> *>(VT_INT_VALUES);
  }
  const flatbuffers::Vector<float> *float_values() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_FLOAT_VALUES);
  }
  flatbuffers::Vector<float> *mutable_float_values() {
    return GetPointer<flatbuffers::Vector<float> *>(VT_FLOAT_VALUES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *string_values() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_STRING_VALUES);
  }
  flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *mutable_string_values() {
    return GetPointer<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_STRING_VALUES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_TRANSFORMS) &&
           verifier.Verify(transforms()) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.Verify(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyOffset(verifier, VT_MESHES) &&
           verifier.Verify(meshes()) &&
           verifier.VerifyVectorOfTables(meshes()) &&
           VerifyOffset(verifier, VT_ANIM_STACKS) &&
           verifier.Verify(anim_stacks()) &&
           VerifyOffset(verifier, VT_ANIM_LAYERS) &&
           verifier.Verify(anim_layers()) &&
           VerifyOffset(verifier, VT_ANIM_CURVES) &&
           verifier.Verify(anim_curves()) &&
           verifier.VerifyVectorOfTables(anim_curves()) &&
           VerifyOffset(verifier, VT_MATERIALS) &&
           verifier.Verify(materials()) &&
           verifier.VerifyVectorOfTables(materials()) &&
           VerifyOffset(verifier, VT_TEXTURES) &&
           verifier.Verify(textures()) &&
           VerifyOffset(verifier, VT_CAMERAS) &&
           verifier.Verify(cameras()) &&
           VerifyOffset(verifier, VT_LIGHTS) &&
           verifier.Verify(lights()) &&
           VerifyOffset(verifier, VT_SKINS) &&
           verifier.Verify(skins()) &&
           verifier.VerifyVectorOfTables(skins()) &&
           VerifyOffset(verifier, VT_FILES) &&
           verifier.Verify(files()) &&
           verifier.VerifyVectorOfTables(files()) &&
           VerifyOffset(verifier, VT_BOOL_VALUES) &&
           verifier.Verify(bool_values()) &&
           VerifyOffset(verifier, VT_INT_VALUES) &&
           verifier.Verify(int_values()) &&
           VerifyOffset(verifier, VT_FLOAT_VALUES) &&
           verifier.Verify(float_values()) &&
           VerifyOffset(verifier, VT_STRING_VALUES) &&
           verifier.Verify(string_values()) &&
           verifier.VerifyVectorOfStrings(string_values()) &&
           verifier.EndTable();
  }
};

struct SceneFbBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(EVersionFb version) {
    fbb_.AddElement<uint8_t>(SceneFb::VT_VERSION, static_cast<uint8_t>(version), 0);
  }
  void add_transforms(flatbuffers::Offset<flatbuffers::Vector<const TransformFb *>> transforms) {
    fbb_.AddOffset(SceneFb::VT_TRANSFORMS, transforms);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeFb>>> nodes) {
    fbb_.AddOffset(SceneFb::VT_NODES, nodes);
  }
  void add_meshes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MeshFb>>> meshes) {
    fbb_.AddOffset(SceneFb::VT_MESHES, meshes);
  }
  void add_anim_stacks(flatbuffers::Offset<flatbuffers::Vector<const AnimStackFb *>> anim_stacks) {
    fbb_.AddOffset(SceneFb::VT_ANIM_STACKS, anim_stacks);
  }
  void add_anim_layers(flatbuffers::Offset<flatbuffers::Vector<const AnimLayerFb *>> anim_layers) {
    fbb_.AddOffset(SceneFb::VT_ANIM_LAYERS, anim_layers);
  }
  void add_anim_curves(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimCurveFb>>> anim_curves) {
    fbb_.AddOffset(SceneFb::VT_ANIM_CURVES, anim_curves);
  }
  void add_materials(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MaterialFb>>> materials) {
    fbb_.AddOffset(SceneFb::VT_MATERIALS, materials);
  }
  void add_textures(flatbuffers::Offset<flatbuffers::Vector<const TextureFb *>> textures) {
    fbb_.AddOffset(SceneFb::VT_TEXTURES, textures);
  }
  void add_cameras(flatbuffers::Offset<flatbuffers::Vector<const CameraFb *>> cameras) {
    fbb_.AddOffset(SceneFb::VT_CAMERAS, cameras);
  }
  void add_lights(flatbuffers::Offset<flatbuffers::Vector<const LightFb *>> lights) {
    fbb_.AddOffset(SceneFb::VT_LIGHTS, lights);
  }
  void add_skins(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SkinFb>>> skins) {
    fbb_.AddOffset(SceneFb::VT_SKINS, skins);
  }
  void add_files(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FileFb>>> files) {
    fbb_.AddOffset(SceneFb::VT_FILES, files);
  }
  void add_bool_values(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bool_values) {
    fbb_.AddOffset(SceneFb::VT_BOOL_VALUES, bool_values);
  }
  void add_int_values(flatbuffers::Offset<flatbuffers::Vector<int32_t>> int_values) {
    fbb_.AddOffset(SceneFb::VT_INT_VALUES, int_values);
  }
  void add_float_values(flatbuffers::Offset<flatbuffers::Vector<float>> float_values) {
    fbb_.AddOffset(SceneFb::VT_FLOAT_VALUES, float_values);
  }
  void add_string_values(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> string_values) {
    fbb_.AddOffset(SceneFb::VT_STRING_VALUES, string_values);
  }
  explicit SceneFbBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SceneFbBuilder &operator=(const SceneFbBuilder &);
  flatbuffers::Offset<SceneFb> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SceneFb>(end);
    return o;
  }
};

inline flatbuffers::Offset<SceneFb> CreateSceneFb(
    flatbuffers::FlatBufferBuilder &_fbb,
    EVersionFb version = static_cast<EVersionFb>(0),
    flatbuffers::Offset<flatbuffers::Vector<const TransformFb *>> transforms = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeFb>>> nodes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MeshFb>>> meshes = 0,
    flatbuffers::Offset<flatbuffers::Vector<const AnimStackFb *>> anim_stacks = 0,
    flatbuffers::Offset<flatbuffers::Vector<const AnimLayerFb *>> anim_layers = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimCurveFb>>> anim_curves = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<MaterialFb>>> materials = 0,
    flatbuffers::Offset<flatbuffers::Vector<const TextureFb *>> textures = 0,
    flatbuffers::Offset<flatbuffers::Vector<const CameraFb *>> cameras = 0,
    flatbuffers::Offset<flatbuffers::Vector<const LightFb *>> lights = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SkinFb>>> skins = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<FileFb>>> files = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bool_values = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> int_values = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> float_values = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> string_values = 0) {
  SceneFbBuilder builder_(_fbb);
  builder_.add_string_values(string_values);
  builder_.add_float_values(float_values);
  builder_.add_int_values(int_values);
  builder_.add_bool_values(bool_values);
  builder_.add_files(files);
  builder_.add_skins(skins);
  builder_.add_lights(lights);
  builder_.add_cameras(cameras);
  builder_.add_textures(textures);
  builder_.add_materials(materials);
  builder_.add_anim_curves(anim_curves);
  builder_.add_anim_layers(anim_layers);
  builder_.add_anim_stacks(anim_stacks);
  builder_.add_meshes(meshes);
  builder_.add_nodes(nodes);
  builder_.add_transforms(transforms);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<SceneFb> CreateSceneFbDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    EVersionFb version = static_cast<EVersionFb>(0),
    const std::vector<const TransformFb *> *transforms = nullptr,
    const std::vector<flatbuffers::Offset<NodeFb>> *nodes = nullptr,
    const std::vector<flatbuffers::Offset<MeshFb>> *meshes = nullptr,
    const std::vector<const AnimStackFb *> *anim_stacks = nullptr,
    const std::vector<const AnimLayerFb *> *anim_layers = nullptr,
    const std::vector<flatbuffers::Offset<AnimCurveFb>> *anim_curves = nullptr,
    const std::vector<flatbuffers::Offset<MaterialFb>> *materials = nullptr,
    const std::vector<const TextureFb *> *textures = nullptr,
    const std::vector<const CameraFb *> *cameras = nullptr,
    const std::vector<const LightFb *> *lights = nullptr,
    const std::vector<flatbuffers::Offset<SkinFb>> *skins = nullptr,
    const std::vector<flatbuffers::Offset<FileFb>> *files = nullptr,
    const std::vector<uint8_t> *bool_values = nullptr,
    const std::vector<int32_t> *int_values = nullptr,
    const std::vector<float> *float_values = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *string_values = nullptr) {
  return apemodefb::CreateSceneFb(
      _fbb,
      version,
      transforms ? _fbb.CreateVector<const TransformFb *>(*transforms) : 0,
      nodes ? _fbb.CreateVector<flatbuffers::Offset<NodeFb>>(*nodes) : 0,
      meshes ? _fbb.CreateVector<flatbuffers::Offset<MeshFb>>(*meshes) : 0,
      anim_stacks ? _fbb.CreateVector<const AnimStackFb *>(*anim_stacks) : 0,
      anim_layers ? _fbb.CreateVector<const AnimLayerFb *>(*anim_layers) : 0,
      anim_curves ? _fbb.CreateVector<flatbuffers::Offset<AnimCurveFb>>(*anim_curves) : 0,
      materials ? _fbb.CreateVector<flatbuffers::Offset<MaterialFb>>(*materials) : 0,
      textures ? _fbb.CreateVector<const TextureFb *>(*textures) : 0,
      cameras ? _fbb.CreateVector<const CameraFb *>(*cameras) : 0,
      lights ? _fbb.CreateVector<const LightFb *>(*lights) : 0,
      skins ? _fbb.CreateVector<flatbuffers::Offset<SkinFb>>(*skins) : 0,
      files ? _fbb.CreateVector<flatbuffers::Offset<FileFb>>(*files) : 0,
      bool_values ? _fbb.CreateVector<uint8_t>(*bool_values) : 0,
      int_values ? _fbb.CreateVector<int32_t>(*int_values) : 0,
      float_values ? _fbb.CreateVector<float>(*float_values) : 0,
      string_values ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*string_values) : 0);
}

inline const apemodefb::SceneFb *GetSceneFb(const void *buf) {
  return flatbuffers::GetRoot<apemodefb::SceneFb>(buf);
}

inline SceneFb *GetMutableSceneFb(void *buf) {
  return flatbuffers::GetMutableRoot<SceneFb>(buf);
}

inline const char *SceneFbIdentifier() {
  return "FBXP";
}

inline bool SceneFbBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, SceneFbIdentifier());
}

inline bool VerifySceneFbBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<apemodefb::SceneFb>(SceneFbIdentifier());
}

inline const char *SceneFbExtension() {
  return "fbxp";
}

inline void FinishSceneFbBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<apemodefb::SceneFb> root) {
  fbb.Finish(root, SceneFbIdentifier());
}

}  // namespace apemodefb

#endif  // FLATBUFFERS_GENERATED_SCENE_APEMODEFB_H_
